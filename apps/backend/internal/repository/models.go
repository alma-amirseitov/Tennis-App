// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0

package repository

import (
	"database/sql/driver"
	"fmt"
	"net/netip"

	"github.com/jackc/pgx/v5/pgtype"
)

type ChatType string

const (
	ChatTypePersonal  ChatType = "personal"
	ChatTypeCommunity ChatType = "community"
	ChatTypeEvent     ChatType = "event"
)

func (e *ChatType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ChatType(s)
	case string:
		*e = ChatType(s)
	default:
		return fmt.Errorf("unsupported scan type for ChatType: %T", src)
	}
	return nil
}

type NullChatType struct {
	ChatType ChatType `json:"chat_type"`
	Valid    bool     `json:"valid"` // Valid is true if ChatType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullChatType) Scan(value interface{}) error {
	if value == nil {
		ns.ChatType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ChatType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullChatType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ChatType), nil
}

type CommunityAccess string

const (
	CommunityAccessOpen   CommunityAccess = "open"
	CommunityAccessClosed CommunityAccess = "closed"
	CommunityAccessPaid   CommunityAccess = "paid"
)

func (e *CommunityAccess) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CommunityAccess(s)
	case string:
		*e = CommunityAccess(s)
	default:
		return fmt.Errorf("unsupported scan type for CommunityAccess: %T", src)
	}
	return nil
}

type NullCommunityAccess struct {
	CommunityAccess CommunityAccess `json:"community_access"`
	Valid           bool            `json:"valid"` // Valid is true if CommunityAccess is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCommunityAccess) Scan(value interface{}) error {
	if value == nil {
		ns.CommunityAccess, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CommunityAccess.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCommunityAccess) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CommunityAccess), nil
}

type CommunityRole string

const (
	CommunityRoleOwner        CommunityRole = "owner"
	CommunityRoleAdmin        CommunityRole = "admin"
	CommunityRoleModerator    CommunityRole = "moderator"
	CommunityRoleCoachReferee CommunityRole = "coach_referee"
	CommunityRoleMember       CommunityRole = "member"
)

func (e *CommunityRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CommunityRole(s)
	case string:
		*e = CommunityRole(s)
	default:
		return fmt.Errorf("unsupported scan type for CommunityRole: %T", src)
	}
	return nil
}

type NullCommunityRole struct {
	CommunityRole CommunityRole `json:"community_role"`
	Valid         bool          `json:"valid"` // Valid is true if CommunityRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCommunityRole) Scan(value interface{}) error {
	if value == nil {
		ns.CommunityRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CommunityRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCommunityRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CommunityRole), nil
}

type CommunityType string

const (
	CommunityTypeClub      CommunityType = "club"
	CommunityTypeLeague    CommunityType = "league"
	CommunityTypeOrganizer CommunityType = "organizer"
	CommunityTypeGroup     CommunityType = "group"
)

func (e *CommunityType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CommunityType(s)
	case string:
		*e = CommunityType(s)
	default:
		return fmt.Errorf("unsupported scan type for CommunityType: %T", src)
	}
	return nil
}

type NullCommunityType struct {
	CommunityType CommunityType `json:"community_type"`
	Valid         bool          `json:"valid"` // Valid is true if CommunityType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCommunityType) Scan(value interface{}) error {
	if value == nil {
		ns.CommunityType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CommunityType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCommunityType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CommunityType), nil
}

type CourtSurface string

const (
	CourtSurfaceHard      CourtSurface = "hard"
	CourtSurfaceClay      CourtSurface = "clay"
	CourtSurfaceCarpet    CourtSurface = "carpet"
	CourtSurfaceGrass     CourtSurface = "grass"
	CourtSurfaceSynthetic CourtSurface = "synthetic"
)

func (e *CourtSurface) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = CourtSurface(s)
	case string:
		*e = CourtSurface(s)
	default:
		return fmt.Errorf("unsupported scan type for CourtSurface: %T", src)
	}
	return nil
}

type NullCourtSurface struct {
	CourtSurface CourtSurface `json:"court_surface"`
	Valid        bool         `json:"valid"` // Valid is true if CourtSurface is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullCourtSurface) Scan(value interface{}) error {
	if value == nil {
		ns.CourtSurface, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.CourtSurface.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullCourtSurface) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.CourtSurface), nil
}

type EventStatus string

const (
	EventStatusDraft              EventStatus = "draft"
	EventStatusPublished          EventStatus = "published"
	EventStatusRegistrationOpen   EventStatus = "registration_open"
	EventStatusRegistrationClosed EventStatus = "registration_closed"
	EventStatusInProgress         EventStatus = "in_progress"
	EventStatusCompleted          EventStatus = "completed"
	EventStatusCancelled          EventStatus = "cancelled"
	EventStatusArchived           EventStatus = "archived"
)

func (e *EventStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventStatus(s)
	case string:
		*e = EventStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for EventStatus: %T", src)
	}
	return nil
}

type NullEventStatus struct {
	EventStatus EventStatus `json:"event_status"`
	Valid       bool        `json:"valid"` // Valid is true if EventStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventStatus) Scan(value interface{}) error {
	if value == nil {
		ns.EventStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventStatus), nil
}

type EventType string

const (
	EventTypeFindPartner   EventType = "find_partner"
	EventTypeOrganizedGame EventType = "organized_game"
	EventTypeTournament    EventType = "tournament"
	EventTypeTraining      EventType = "training"
)

func (e *EventType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = EventType(s)
	case string:
		*e = EventType(s)
	default:
		return fmt.Errorf("unsupported scan type for EventType: %T", src)
	}
	return nil
}

type NullEventType struct {
	EventType EventType `json:"event_type"`
	Valid     bool      `json:"valid"` // Valid is true if EventType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullEventType) Scan(value interface{}) error {
	if value == nil {
		ns.EventType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.EventType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullEventType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.EventType), nil
}

type GenderType string

const (
	GenderTypeMale   GenderType = "male"
	GenderTypeFemale GenderType = "female"
	GenderTypeOther  GenderType = "other"
)

func (e *GenderType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = GenderType(s)
	case string:
		*e = GenderType(s)
	default:
		return fmt.Errorf("unsupported scan type for GenderType: %T", src)
	}
	return nil
}

type NullGenderType struct {
	GenderType GenderType `json:"gender_type"`
	Valid      bool       `json:"valid"` // Valid is true if GenderType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullGenderType) Scan(value interface{}) error {
	if value == nil {
		ns.GenderType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.GenderType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullGenderType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.GenderType), nil
}

type MatchFormat string

const (
	MatchFormatBestOf   MatchFormat = "best_of"
	MatchFormatProSet   MatchFormat = "pro_set"
	MatchFormatShortSet MatchFormat = "short_set"
	MatchFormatTimed    MatchFormat = "timed"
	MatchFormatCustom   MatchFormat = "custom"
)

func (e *MatchFormat) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MatchFormat(s)
	case string:
		*e = MatchFormat(s)
	default:
		return fmt.Errorf("unsupported scan type for MatchFormat: %T", src)
	}
	return nil
}

type NullMatchFormat struct {
	MatchFormat MatchFormat `json:"match_format"`
	Valid       bool        `json:"valid"` // Valid is true if MatchFormat is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMatchFormat) Scan(value interface{}) error {
	if value == nil {
		ns.MatchFormat, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MatchFormat.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMatchFormat) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MatchFormat), nil
}

type MemberStatus string

const (
	MemberStatusPending MemberStatus = "pending"
	MemberStatusActive  MemberStatus = "active"
	MemberStatusBanned  MemberStatus = "banned"
	MemberStatusLeft    MemberStatus = "left"
)

func (e *MemberStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = MemberStatus(s)
	case string:
		*e = MemberStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for MemberStatus: %T", src)
	}
	return nil
}

type NullMemberStatus struct {
	MemberStatus MemberStatus `json:"member_status"`
	Valid        bool         `json:"valid"` // Valid is true if MemberStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullMemberStatus) Scan(value interface{}) error {
	if value == nil {
		ns.MemberStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.MemberStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullMemberStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.MemberStatus), nil
}

type NotificationType string

const (
	NotificationTypeEventResponse   NotificationType = "event_response"
	NotificationTypeGameReminder24h NotificationType = "game_reminder_24h"
	NotificationTypeGameReminder1h  NotificationType = "game_reminder_1h"
	NotificationTypeResultConfirm   NotificationType = "result_confirm"
	NotificationTypeCommunityNews   NotificationType = "community_news"
	NotificationTypeNewMessage      NotificationType = "new_message"
	NotificationTypeRatingChange    NotificationType = "rating_change"
	NotificationTypeNewBadge        NotificationType = "new_badge"
	NotificationTypeJoinRequest     NotificationType = "join_request"
	NotificationTypeJoinApproved    NotificationType = "join_approved"
	NotificationTypeJoinRejected    NotificationType = "join_rejected"
	NotificationTypeEventCancelled  NotificationType = "event_cancelled"
	NotificationTypeSpotAvailable   NotificationType = "spot_available"
)

func (e *NotificationType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = NotificationType(s)
	case string:
		*e = NotificationType(s)
	default:
		return fmt.Errorf("unsupported scan type for NotificationType: %T", src)
	}
	return nil
}

type NullNotificationType struct {
	NotificationType NotificationType `json:"notification_type"`
	Valid            bool             `json:"valid"` // Valid is true if NotificationType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullNotificationType) Scan(value interface{}) error {
	if value == nil {
		ns.NotificationType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.NotificationType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullNotificationType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.NotificationType), nil
}

type ParticipantStatus string

const (
	ParticipantStatusRegistered ParticipantStatus = "registered"
	ParticipantStatusConfirmed  ParticipantStatus = "confirmed"
	ParticipantStatusCheckedIn  ParticipantStatus = "checked_in"
	ParticipantStatusNoShow     ParticipantStatus = "no_show"
	ParticipantStatusCancelled  ParticipantStatus = "cancelled"
)

func (e *ParticipantStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ParticipantStatus(s)
	case string:
		*e = ParticipantStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ParticipantStatus: %T", src)
	}
	return nil
}

type NullParticipantStatus struct {
	ParticipantStatus ParticipantStatus `json:"participant_status"`
	Valid             bool              `json:"valid"` // Valid is true if ParticipantStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullParticipantStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ParticipantStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ParticipantStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullParticipantStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ParticipantStatus), nil
}

type PlatformRole string

const (
	PlatformRolePlayer     PlatformRole = "player"
	PlatformRoleSuperadmin PlatformRole = "superadmin"
)

func (e *PlatformRole) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlatformRole(s)
	case string:
		*e = PlatformRole(s)
	default:
		return fmt.Errorf("unsupported scan type for PlatformRole: %T", src)
	}
	return nil
}

type NullPlatformRole struct {
	PlatformRole PlatformRole `json:"platform_role"`
	Valid        bool         `json:"valid"` // Valid is true if PlatformRole is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlatformRole) Scan(value interface{}) error {
	if value == nil {
		ns.PlatformRole, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlatformRole.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlatformRole) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlatformRole), nil
}

type PlayerComposition string

const (
	PlayerCompositionSingles PlayerComposition = "singles"
	PlayerCompositionDoubles PlayerComposition = "doubles"
	PlayerCompositionMixed   PlayerComposition = "mixed"
	PlayerCompositionTeam    PlayerComposition = "team"
	PlayerCompositionCustom  PlayerComposition = "custom"
)

func (e *PlayerComposition) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PlayerComposition(s)
	case string:
		*e = PlayerComposition(s)
	default:
		return fmt.Errorf("unsupported scan type for PlayerComposition: %T", src)
	}
	return nil
}

type NullPlayerComposition struct {
	PlayerComposition PlayerComposition `json:"player_composition"`
	Valid             bool              `json:"valid"` // Valid is true if PlayerComposition is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPlayerComposition) Scan(value interface{}) error {
	if value == nil {
		ns.PlayerComposition, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PlayerComposition.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPlayerComposition) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PlayerComposition), nil
}

type PostAuthorType string

const (
	PostAuthorTypeUser      PostAuthorType = "user"
	PostAuthorTypeCommunity PostAuthorType = "community"
)

func (e *PostAuthorType) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = PostAuthorType(s)
	case string:
		*e = PostAuthorType(s)
	default:
		return fmt.Errorf("unsupported scan type for PostAuthorType: %T", src)
	}
	return nil
}

type NullPostAuthorType struct {
	PostAuthorType PostAuthorType `json:"post_author_type"`
	Valid          bool           `json:"valid"` // Valid is true if PostAuthorType is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullPostAuthorType) Scan(value interface{}) error {
	if value == nil {
		ns.PostAuthorType, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.PostAuthorType.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullPostAuthorType) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.PostAuthorType), nil
}

type ResultStatus string

const (
	ResultStatusPending        ResultStatus = "pending"
	ResultStatusConfirmed      ResultStatus = "confirmed"
	ResultStatusDisputed       ResultStatus = "disputed"
	ResultStatusAdminConfirmed ResultStatus = "admin_confirmed"
)

func (e *ResultStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = ResultStatus(s)
	case string:
		*e = ResultStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for ResultStatus: %T", src)
	}
	return nil
}

type NullResultStatus struct {
	ResultStatus ResultStatus `json:"result_status"`
	Valid        bool         `json:"valid"` // Valid is true if ResultStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullResultStatus) Scan(value interface{}) error {
	if value == nil {
		ns.ResultStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.ResultStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullResultStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.ResultStatus), nil
}

type TournamentSystem string

const (
	TournamentSystemKnockout          TournamentSystem = "knockout"
	TournamentSystemRoundRobin        TournamentSystem = "round_robin"
	TournamentSystemSwiss             TournamentSystem = "swiss"
	TournamentSystemDoubleElimination TournamentSystem = "double_elimination"
	TournamentSystemGroupsPlayoff     TournamentSystem = "groups_playoff"
)

func (e *TournamentSystem) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = TournamentSystem(s)
	case string:
		*e = TournamentSystem(s)
	default:
		return fmt.Errorf("unsupported scan type for TournamentSystem: %T", src)
	}
	return nil
}

type NullTournamentSystem struct {
	TournamentSystem TournamentSystem `json:"tournament_system"`
	Valid            bool             `json:"valid"` // Valid is true if TournamentSystem is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullTournamentSystem) Scan(value interface{}) error {
	if value == nil {
		ns.TournamentSystem, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.TournamentSystem.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullTournamentSystem) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.TournamentSystem), nil
}

type UserStatus string

const (
	UserStatusActive  UserStatus = "active"
	UserStatusBanned  UserStatus = "banned"
	UserStatusDeleted UserStatus = "deleted"
)

func (e *UserStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = UserStatus(s)
	case string:
		*e = UserStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for UserStatus: %T", src)
	}
	return nil
}

type NullUserStatus struct {
	UserStatus UserStatus `json:"user_status"`
	Valid      bool       `json:"valid"` // Valid is true if UserStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullUserStatus) Scan(value interface{}) error {
	if value == nil {
		ns.UserStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.UserStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullUserStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.UserStatus), nil
}

type VerificationStatus string

const (
	VerificationStatusNone     VerificationStatus = "none"
	VerificationStatusPending  VerificationStatus = "pending"
	VerificationStatusVerified VerificationStatus = "verified"
	VerificationStatusRejected VerificationStatus = "rejected"
)

func (e *VerificationStatus) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = VerificationStatus(s)
	case string:
		*e = VerificationStatus(s)
	default:
		return fmt.Errorf("unsupported scan type for VerificationStatus: %T", src)
	}
	return nil
}

type NullVerificationStatus struct {
	VerificationStatus VerificationStatus `json:"verification_status"`
	Valid              bool               `json:"valid"` // Valid is true if VerificationStatus is not NULL
}

// Scan implements the Scanner interface.
func (ns *NullVerificationStatus) Scan(value interface{}) error {
	if value == nil {
		ns.VerificationStatus, ns.Valid = "", false
		return nil
	}
	ns.Valid = true
	return ns.VerificationStatus.Scan(value)
}

// Value implements the driver Valuer interface.
func (ns NullVerificationStatus) Value() (driver.Value, error) {
	if !ns.Valid {
		return nil, nil
	}
	return string(ns.VerificationStatus), nil
}

type AuditLog struct {
	ID         int64              `json:"id"`
	ActorID    pgtype.UUID        `json:"actor_id"`
	Action     string             `json:"action"`
	EntityType pgtype.Text        `json:"entity_type"`
	EntityID   pgtype.UUID        `json:"entity_id"`
	Details    []byte             `json:"details"`
	IpAddress  *netip.Addr        `json:"ip_address"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type BadgeDefinition struct {
	ID             string      `json:"id"`
	NameRu         string      `json:"name_ru"`
	NameKz         pgtype.Text `json:"name_kz"`
	NameEn         pgtype.Text `json:"name_en"`
	DescriptionRu  pgtype.Text `json:"description_ru"`
	DescriptionKz  pgtype.Text `json:"description_kz"`
	DescriptionEn  pgtype.Text `json:"description_en"`
	Icon           pgtype.Text `json:"icon"`
	ConditionType  string      `json:"condition_type"`
	ConditionValue int32       `json:"condition_value"`
	SortOrder      pgtype.Int4 `json:"sort_order"`
}

type Chat struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
}

type ChatReadStatus struct {
	ChatID     pgtype.UUID        `json:"chat_id"`
	UserID     pgtype.UUID        `json:"user_id"`
	LastReadAt pgtype.Timestamptz `json:"last_read_at"`
	IsMuted    pgtype.Bool        `json:"is_muted"`
}

type Community struct {
	ID                    pgtype.UUID            `json:"id"`
	Name                  string                 `json:"name"`
	Slug                  pgtype.Text            `json:"slug"`
	Description           pgtype.Text            `json:"description"`
	Rules                 pgtype.Text            `json:"rules"`
	CommunityType         CommunityType          `json:"community_type"`
	AccessLevel           NullCommunityAccess    `json:"access_level"`
	VerificationStatus    NullVerificationStatus `json:"verification_status"`
	VerifiedAt            pgtype.Timestamptz     `json:"verified_at"`
	VerificationDocuments []byte                 `json:"verification_documents"`
	LogoUrl               pgtype.Text            `json:"logo_url"`
	BannerUrl             pgtype.Text            `json:"banner_url"`
	ContactPhone          pgtype.Text            `json:"contact_phone"`
	ContactEmail          pgtype.Text            `json:"contact_email"`
	SocialLinks           []byte                 `json:"social_links"`
	Address               pgtype.Text            `json:"address"`
	District              pgtype.Text            `json:"district"`
	RatingInitial         pgtype.Numeric         `json:"rating_initial"`
	RatingKFactor         pgtype.Int4            `json:"rating_k_factor"`
	RatingMinGames        pgtype.Int4            `json:"rating_min_games"`
	MemberCount           pgtype.Int4            `json:"member_count"`
	EventCount            pgtype.Int4            `json:"event_count"`
	IsActive              pgtype.Bool            `json:"is_active"`
	CreatedBy             pgtype.UUID            `json:"created_by"`
	CreatedAt             pgtype.Timestamptz     `json:"created_at"`
	UpdatedAt             pgtype.Timestamptz     `json:"updated_at"`
}

type CommunityMember struct {
	ID                  pgtype.UUID        `json:"id"`
	CommunityID         pgtype.UUID        `json:"community_id"`
	UserID              pgtype.UUID        `json:"user_id"`
	Role                NullCommunityRole  `json:"role"`
	Status              NullMemberStatus   `json:"status"`
	ApplicationMessage  pgtype.Text        `json:"application_message"`
	ReviewedBy          pgtype.UUID        `json:"reviewed_by"`
	ReviewedAt          pgtype.Timestamptz `json:"reviewed_at"`
	CommunityRating     pgtype.Numeric     `json:"community_rating"`
	CommunityGamesCount pgtype.Int4        `json:"community_games_count"`
	CommunityWins       pgtype.Int4        `json:"community_wins"`
	CommunityLosses     pgtype.Int4        `json:"community_losses"`
	JoinedAt            pgtype.Timestamptz `json:"joined_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

type Court struct {
	ID            pgtype.UUID        `json:"id"`
	Name          string             `json:"name"`
	Address       string             `json:"address"`
	District      pgtype.Text        `json:"district"`
	Latitude      pgtype.Numeric     `json:"latitude"`
	Longitude     pgtype.Numeric     `json:"longitude"`
	TotalCourts   pgtype.Int2        `json:"total_courts"`
	IndoorCourts  pgtype.Int2        `json:"indoor_courts"`
	OutdoorCourts pgtype.Int2        `json:"outdoor_courts"`
	Surface       NullCourtSurface   `json:"surface"`
	PricePerHour  pgtype.Numeric     `json:"price_per_hour"`
	Currency      pgtype.Text        `json:"currency"`
	Phone         pgtype.Text        `json:"phone"`
	WorkingHours  []byte             `json:"working_hours"`
	Photos        []byte             `json:"photos"`
	CommunityID   pgtype.UUID        `json:"community_id"`
	IsActive      pgtype.Bool        `json:"is_active"`
	CreatedBy     pgtype.UUID        `json:"created_by"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

type Event struct {
	ID                   pgtype.UUID          `json:"id"`
	Title                string               `json:"title"`
	Description          pgtype.Text          `json:"description"`
	EventType            EventType            `json:"event_type"`
	Status               NullEventStatus      `json:"status"`
	CommunityID          pgtype.UUID          `json:"community_id"`
	PlayerComposition    PlayerComposition    `json:"player_composition"`
	MatchFormat          NullMatchFormat      `json:"match_format"`
	MatchFormatDetails   []byte               `json:"match_format_details"`
	TournamentSystem     NullTournamentSystem `json:"tournament_system"`
	TournamentDetails    []byte               `json:"tournament_details"`
	CourtID              pgtype.UUID          `json:"court_id"`
	LocationName         pgtype.Text          `json:"location_name"`
	LocationAddress      pgtype.Text          `json:"location_address"`
	StartTime            pgtype.Timestamptz   `json:"start_time"`
	EndTime              pgtype.Timestamptz   `json:"end_time"`
	MaxParticipants      pgtype.Int4          `json:"max_participants"`
	MinParticipants      pgtype.Int4          `json:"min_participants"`
	CurrentParticipants  pgtype.Int4          `json:"current_participants"`
	MinLevel             pgtype.Numeric       `json:"min_level"`
	MaxLevel             pgtype.Numeric       `json:"max_level"`
	GenderRestriction    NullGenderType       `json:"gender_restriction"`
	MinAge               pgtype.Int2          `json:"min_age"`
	MaxAge               pgtype.Int2          `json:"max_age"`
	RegistrationDeadline pgtype.Timestamptz   `json:"registration_deadline"`
	IsPaid               pgtype.Bool          `json:"is_paid"`
	PriceAmount          pgtype.Numeric       `json:"price_amount"`
	PriceCurrency        pgtype.Text          `json:"price_currency"`
	CreatedBy            pgtype.UUID          `json:"created_by"`
	CreatedAt            pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz   `json:"updated_at"`
}

type EventParticipant struct {
	ID           pgtype.UUID           `json:"id"`
	EventID      pgtype.UUID           `json:"event_id"`
	UserID       pgtype.UUID           `json:"user_id"`
	Status       NullParticipantStatus `json:"status"`
	RegisteredAt pgtype.Timestamptz    `json:"registered_at"`
	CancelledAt  pgtype.Timestamptz    `json:"cancelled_at"`
	PartnerID    pgtype.UUID           `json:"partner_id"`
	SeedNumber   pgtype.Int4           `json:"seed_number"`
}

type Friend struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	FriendID  pgtype.UUID        `json:"friend_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Match struct {
	ID                  pgtype.UUID        `json:"id"`
	EventID             pgtype.UUID        `json:"event_id"`
	CommunityID         pgtype.UUID        `json:"community_id"`
	Player1ID           pgtype.UUID        `json:"player1_id"`
	Player2ID           pgtype.UUID        `json:"player2_id"`
	Player1PartnerID    pgtype.UUID        `json:"player1_partner_id"`
	Player2PartnerID    pgtype.UUID        `json:"player2_partner_id"`
	Composition         PlayerComposition  `json:"composition"`
	Score               []byte             `json:"score"`
	WinnerID            pgtype.UUID        `json:"winner_id"`
	ResultStatus        NullResultStatus   `json:"result_status"`
	SubmittedBy         pgtype.UUID        `json:"submitted_by"`
	ConfirmedBy         pgtype.UUID        `json:"confirmed_by"`
	SubmittedAt         pgtype.Timestamptz `json:"submitted_at"`
	ConfirmedAt         pgtype.Timestamptz `json:"confirmed_at"`
	DisputeReason       pgtype.Text        `json:"dispute_reason"`
	Player1RatingBefore pgtype.Numeric     `json:"player1_rating_before"`
	Player1RatingAfter  pgtype.Numeric     `json:"player1_rating_after"`
	Player2RatingBefore pgtype.Numeric     `json:"player2_rating_before"`
	Player2RatingAfter  pgtype.Numeric     `json:"player2_rating_after"`
	RoundName           pgtype.Text        `json:"round_name"`
	RoundNumber         pgtype.Int4        `json:"round_number"`
	CourtNumber         pgtype.Int4        `json:"court_number"`
	ScheduledTime       pgtype.Timestamptz `json:"scheduled_time"`
	PlayedAt            pgtype.Timestamptz `json:"played_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
}

type Message struct {
	ID        pgtype.UUID        `json:"id"`
	ChatID    pgtype.UUID        `json:"chat_id"`
	SenderID  pgtype.UUID        `json:"sender_id"`
	Content   string             `json:"content"`
	ReplyToID pgtype.UUID        `json:"reply_to_id"`
	IsDeleted pgtype.Bool        `json:"is_deleted"`
	DeletedAt pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type Notification struct {
	ID        pgtype.UUID        `json:"id"`
	UserID    pgtype.UUID        `json:"user_id"`
	Type      NotificationType   `json:"type"`
	Title     string             `json:"title"`
	Body      string             `json:"body"`
	Data      []byte             `json:"data"`
	IsRead    pgtype.Bool        `json:"is_read"`
	IsPushed  pgtype.Bool        `json:"is_pushed"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

type OtpSession struct {
	ID          pgtype.UUID        `json:"id"`
	Phone       string             `json:"phone"`
	Code        string             `json:"code"`
	Attempts    pgtype.Int4        `json:"attempts"`
	MaxAttempts pgtype.Int4        `json:"max_attempts"`
	IsVerified  pgtype.Bool        `json:"is_verified"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
}

type PlayerStatsGlobal struct {
	UserID            pgtype.UUID        `json:"user_id"`
	TotalGames        pgtype.Int4        `json:"total_games"`
	TotalWins         pgtype.Int4        `json:"total_wins"`
	TotalLosses       pgtype.Int4        `json:"total_losses"`
	WinRate           pgtype.Numeric     `json:"win_rate"`
	SinglesGames      pgtype.Int4        `json:"singles_games"`
	SinglesWins       pgtype.Int4        `json:"singles_wins"`
	DoublesGames      pgtype.Int4        `json:"doubles_games"`
	DoublesWins       pgtype.Int4        `json:"doubles_wins"`
	CurrentStreak     pgtype.Int4        `json:"current_streak"`
	BestStreak        pgtype.Int4        `json:"best_streak"`
	TournamentsPlayed pgtype.Int4        `json:"tournaments_played"`
	LastGameAt        pgtype.Timestamptz `json:"last_game_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

type Post struct {
	ID                pgtype.UUID        `json:"id"`
	AuthorType        PostAuthorType     `json:"author_type"`
	AuthorUserID      pgtype.UUID        `json:"author_user_id"`
	AuthorCommunityID pgtype.UUID        `json:"author_community_id"`
	Content           string             `json:"content"`
	Photos            []byte             `json:"photos"`
	LikeCount         pgtype.Int4        `json:"like_count"`
	CommentCount      pgtype.Int4        `json:"comment_count"`
	IsMatchResult     pgtype.Bool        `json:"is_match_result"`
	MatchID           pgtype.UUID        `json:"match_id"`
	IsPublished       pgtype.Bool        `json:"is_published"`
	ScheduledAt       pgtype.Timestamptz `json:"scheduled_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	UpdatedAt         pgtype.Timestamptz `json:"updated_at"`
}

type PostLike struct {
	PostID    pgtype.UUID        `json:"post_id"`
	UserID    pgtype.UUID        `json:"user_id"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
}

type RatingHistory struct {
	ID           int64              `json:"id"`
	UserID       pgtype.UUID        `json:"user_id"`
	CommunityID  pgtype.UUID        `json:"community_id"`
	RatingBefore pgtype.Numeric     `json:"rating_before"`
	RatingAfter  pgtype.Numeric     `json:"rating_after"`
	Change       pgtype.Numeric     `json:"change"`
	MatchID      pgtype.UUID        `json:"match_id"`
	Reason       pgtype.Text        `json:"reason"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
}

type RefreshToken struct {
	ID         pgtype.UUID        `json:"id"`
	UserID     pgtype.UUID        `json:"user_id"`
	TokenHash  string             `json:"token_hash"`
	DeviceInfo pgtype.Text        `json:"device_info"`
	ExpiresAt  pgtype.Timestamptz `json:"expires_at"`
	IsRevoked  pgtype.Bool        `json:"is_revoked"`
	CreatedAt  pgtype.Timestamptz `json:"created_at"`
}

type User struct {
	ID                   pgtype.UUID        `json:"id"`
	Phone                string             `json:"phone"`
	PhoneVerified        pgtype.Bool        `json:"phone_verified"`
	FirstName            pgtype.Text        `json:"first_name"`
	LastName             pgtype.Text        `json:"last_name"`
	Gender               NullGenderType     `json:"gender"`
	BirthYear            pgtype.Int2        `json:"birth_year"`
	City                 pgtype.Text        `json:"city"`
	District             pgtype.Text        `json:"district"`
	AvatarUrl            pgtype.Text        `json:"avatar_url"`
	Bio                  pgtype.Text        `json:"bio"`
	NtrpLevel            pgtype.Numeric     `json:"ntrp_level"`
	LevelLabel           pgtype.Text        `json:"level_label"`
	QuizCompleted        pgtype.Bool        `json:"quiz_completed"`
	GlobalRating         pgtype.Numeric     `json:"global_rating"`
	GlobalGamesCount     pgtype.Int4        `json:"global_games_count"`
	Language             pgtype.Text        `json:"language"`
	PinHash              pgtype.Text        `json:"pin_hash"`
	PushToken            pgtype.Text        `json:"push_token"`
	PlatformRole         NullPlatformRole   `json:"platform_role"`
	ProfileVisibility    pgtype.Text        `json:"profile_visibility"`
	AllowMessagesFrom    pgtype.Text        `json:"allow_messages_from"`
	ShowStats            pgtype.Bool        `json:"show_stats"`
	NotificationSettings []byte             `json:"notification_settings"`
	Status               NullUserStatus     `json:"status"`
	IsProfileComplete    pgtype.Bool        `json:"is_profile_complete"`
	LastActiveAt         pgtype.Timestamptz `json:"last_active_at"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type UserBadge struct {
	ID       pgtype.UUID        `json:"id"`
	UserID   pgtype.UUID        `json:"user_id"`
	BadgeID  string             `json:"badge_id"`
	EarnedAt pgtype.Timestamptz `json:"earned_at"`
}

type VActiveEvent struct {
	ID                   pgtype.UUID          `json:"id"`
	Title                string               `json:"title"`
	Description          pgtype.Text          `json:"description"`
	EventType            EventType            `json:"event_type"`
	Status               NullEventStatus      `json:"status"`
	CommunityID          pgtype.UUID          `json:"community_id"`
	PlayerComposition    PlayerComposition    `json:"player_composition"`
	MatchFormat          NullMatchFormat      `json:"match_format"`
	MatchFormatDetails   []byte               `json:"match_format_details"`
	TournamentSystem     NullTournamentSystem `json:"tournament_system"`
	TournamentDetails    []byte               `json:"tournament_details"`
	CourtID              pgtype.UUID          `json:"court_id"`
	LocationName         pgtype.Text          `json:"location_name"`
	LocationAddress      pgtype.Text          `json:"location_address"`
	StartTime            pgtype.Timestamptz   `json:"start_time"`
	EndTime              pgtype.Timestamptz   `json:"end_time"`
	MaxParticipants      pgtype.Int4          `json:"max_participants"`
	MinParticipants      pgtype.Int4          `json:"min_participants"`
	CurrentParticipants  pgtype.Int4          `json:"current_participants"`
	MinLevel             pgtype.Numeric       `json:"min_level"`
	MaxLevel             pgtype.Numeric       `json:"max_level"`
	GenderRestriction    NullGenderType       `json:"gender_restriction"`
	MinAge               pgtype.Int2          `json:"min_age"`
	MaxAge               pgtype.Int2          `json:"max_age"`
	RegistrationDeadline pgtype.Timestamptz   `json:"registration_deadline"`
	IsPaid               pgtype.Bool          `json:"is_paid"`
	PriceAmount          pgtype.Numeric       `json:"price_amount"`
	PriceCurrency        pgtype.Text          `json:"price_currency"`
	CreatedBy            pgtype.UUID          `json:"created_by"`
	CreatedAt            pgtype.Timestamptz   `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz   `json:"updated_at"`
	CommunityName        pgtype.Text          `json:"community_name"`
	CommunityLogo        pgtype.Text          `json:"community_logo"`
	CommunityType        NullCommunityType    `json:"community_type"`
	CreatorFirstName     pgtype.Text          `json:"creator_first_name"`
	CreatorLastName      pgtype.Text          `json:"creator_last_name"`
	CourtName            pgtype.Text          `json:"court_name"`
	AvailableSpots       int32                `json:"available_spots"`
}

type VCommunityLeaderboard struct {
	CommunityID         pgtype.UUID    `json:"community_id"`
	UserID              pgtype.UUID    `json:"user_id"`
	FirstName           pgtype.Text    `json:"first_name"`
	LastName            pgtype.Text    `json:"last_name"`
	AvatarUrl           pgtype.Text    `json:"avatar_url"`
	NtrpLevel           pgtype.Numeric `json:"ntrp_level"`
	CommunityRating     pgtype.Numeric `json:"community_rating"`
	CommunityGamesCount pgtype.Int4    `json:"community_games_count"`
	CommunityWins       pgtype.Int4    `json:"community_wins"`
	CommunityLosses     pgtype.Int4    `json:"community_losses"`
	WinRate             int32          `json:"win_rate"`
	Rank                int64          `json:"rank"`
}
