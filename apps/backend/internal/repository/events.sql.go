// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: events.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addEventParticipant = `-- name: AddEventParticipant :one
INSERT INTO event_participants (
    event_id, user_id, status, partner_id
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, event_id, user_id, status, registered_at, cancelled_at, partner_id, seed_number
`

type AddEventParticipantParams struct {
	EventID   pgtype.UUID           `json:"event_id"`
	UserID    pgtype.UUID           `json:"user_id"`
	Status    NullParticipantStatus `json:"status"`
	PartnerID pgtype.UUID           `json:"partner_id"`
}

func (q *Queries) AddEventParticipant(ctx context.Context, arg AddEventParticipantParams) (EventParticipant, error) {
	row := q.db.QueryRow(ctx, addEventParticipant,
		arg.EventID,
		arg.UserID,
		arg.Status,
		arg.PartnerID,
	)
	var i EventParticipant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.UserID,
		&i.Status,
		&i.RegisteredAt,
		&i.CancelledAt,
		&i.PartnerID,
		&i.SeedNumber,
	)
	return i, err
}

const checkFriendship = `-- name: CheckFriendship :one
SELECT EXISTS(
    SELECT 1 FROM friends WHERE user_id = $1 AND friend_id = $2
) as is_friend
`

type CheckFriendshipParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	FriendID pgtype.UUID `json:"friend_id"`
}

func (q *Queries) CheckFriendship(ctx context.Context, arg CheckFriendshipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkFriendship, arg.UserID, arg.FriendID)
	var is_friend bool
	err := row.Scan(&is_friend)
	return is_friend, err
}

const countEvents = `-- name: CountEvents :one
SELECT COUNT(*)
FROM events
WHERE ($1::event_type IS NULL OR event_type = $1)
  AND ($2::event_status IS NULL OR status = $2)
  AND ($3::player_composition IS NULL OR player_composition = $3)
  AND ($4::uuid IS NULL OR community_id = $4)
  AND ($5::decimal IS NULL OR max_level >= $5)
  AND ($6::decimal IS NULL OR min_level <= $6)
  AND ($7::timestamptz IS NULL OR start_time >= $7)
  AND ($8::timestamptz IS NULL OR start_time <= $8)
  AND ($9::text IS NULL OR location_address ILIKE '%' || $9 || '%')
  AND status NOT IN ('draft', 'cancelled', 'archived')
`

type CountEventsParams struct {
	EventType   NullEventType         `json:"event_type"`
	EventStatus NullEventStatus       `json:"event_status"`
	Composition NullPlayerComposition `json:"composition"`
	CommunityID pgtype.UUID           `json:"community_id"`
	MinLevel    pgtype.Numeric        `json:"min_level"`
	MaxLevel    pgtype.Numeric        `json:"max_level"`
	DateFrom    pgtype.Timestamptz    `json:"date_from"`
	DateTo      pgtype.Timestamptz    `json:"date_to"`
	District    pgtype.Text           `json:"district"`
}

func (q *Queries) CountEvents(ctx context.Context, arg CountEventsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countEvents,
		arg.EventType,
		arg.EventStatus,
		arg.Composition,
		arg.CommunityID,
		arg.MinLevel,
		arg.MaxLevel,
		arg.DateFrom,
		arg.DateTo,
		arg.District,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMutualCommunities = `-- name: CountMutualCommunities :one
SELECT COUNT(DISTINCT cm1.community_id)
FROM community_members cm1
JOIN community_members cm2 ON cm1.community_id = cm2.community_id
WHERE cm1.user_id = $1 AND cm2.user_id = $2
  AND cm1.status = 'active' AND cm2.status = 'active'
`

type CountMutualCommunitiesParams struct {
	UserID   pgtype.UUID `json:"user_id"`
	UserID_2 pgtype.UUID `json:"user_id_2"`
}

func (q *Queries) CountMutualCommunities(ctx context.Context, arg CountMutualCommunitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMutualCommunities, arg.UserID, arg.UserID_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
    title, description, event_type, status,
    community_id, player_composition, match_format, match_format_details,
    court_id, location_name, location_address,
    start_time, end_time,
    max_participants, min_participants,
    min_level, max_level,
    gender_restriction, registration_deadline,
    is_paid, price_amount, price_currency,
    created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13,
    $14, $15, $16, $17, $18, $19, $20, $21, $22, $23
)
RETURNING id, title, description, event_type, status,
    community_id, player_composition, match_format, match_format_details,
    tournament_system, tournament_details,
    court_id, location_name, location_address,
    start_time, end_time,
    max_participants, min_participants, current_participants,
    min_level, max_level,
    gender_restriction, min_age, max_age,
    registration_deadline,
    is_paid, price_amount, price_currency,
    created_by, created_at, updated_at
`

type CreateEventParams struct {
	Title                string             `json:"title"`
	Description          pgtype.Text        `json:"description"`
	EventType            EventType          `json:"event_type"`
	Status               NullEventStatus    `json:"status"`
	CommunityID          pgtype.UUID        `json:"community_id"`
	PlayerComposition    PlayerComposition  `json:"player_composition"`
	MatchFormat          NullMatchFormat    `json:"match_format"`
	MatchFormatDetails   []byte             `json:"match_format_details"`
	CourtID              pgtype.UUID        `json:"court_id"`
	LocationName         pgtype.Text        `json:"location_name"`
	LocationAddress      pgtype.Text        `json:"location_address"`
	StartTime            pgtype.Timestamptz `json:"start_time"`
	EndTime              pgtype.Timestamptz `json:"end_time"`
	MaxParticipants      pgtype.Int4        `json:"max_participants"`
	MinParticipants      pgtype.Int4        `json:"min_participants"`
	MinLevel             pgtype.Numeric     `json:"min_level"`
	MaxLevel             pgtype.Numeric     `json:"max_level"`
	GenderRestriction    NullGenderType     `json:"gender_restriction"`
	RegistrationDeadline pgtype.Timestamptz `json:"registration_deadline"`
	IsPaid               pgtype.Bool        `json:"is_paid"`
	PriceAmount          pgtype.Numeric     `json:"price_amount"`
	PriceCurrency        pgtype.Text        `json:"price_currency"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent,
		arg.Title,
		arg.Description,
		arg.EventType,
		arg.Status,
		arg.CommunityID,
		arg.PlayerComposition,
		arg.MatchFormat,
		arg.MatchFormatDetails,
		arg.CourtID,
		arg.LocationName,
		arg.LocationAddress,
		arg.StartTime,
		arg.EndTime,
		arg.MaxParticipants,
		arg.MinParticipants,
		arg.MinLevel,
		arg.MaxLevel,
		arg.GenderRestriction,
		arg.RegistrationDeadline,
		arg.IsPaid,
		arg.PriceAmount,
		arg.PriceCurrency,
		arg.CreatedBy,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.EventType,
		&i.Status,
		&i.CommunityID,
		&i.PlayerComposition,
		&i.MatchFormat,
		&i.MatchFormatDetails,
		&i.TournamentSystem,
		&i.TournamentDetails,
		&i.CourtID,
		&i.LocationName,
		&i.LocationAddress,
		&i.StartTime,
		&i.EndTime,
		&i.MaxParticipants,
		&i.MinParticipants,
		&i.CurrentParticipants,
		&i.MinLevel,
		&i.MaxLevel,
		&i.GenderRestriction,
		&i.MinAge,
		&i.MaxAge,
		&i.RegistrationDeadline,
		&i.IsPaid,
		&i.PriceAmount,
		&i.PriceCurrency,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const getCalendarEvents = `-- name: GetCalendarEvents :many
SELECT id, title, event_type, status, start_time, end_time,
    community_id, location_name, current_participants, max_participants
FROM events
WHERE start_time >= $1::timestamptz
  AND start_time < $2::timestamptz
  AND ($3::uuid IS NULL OR community_id = $3)
  AND status NOT IN ('draft', 'cancelled', 'archived')
ORDER BY start_time ASC
`

type GetCalendarEventsParams struct {
	MonthStart  pgtype.Timestamptz `json:"month_start"`
	MonthEnd    pgtype.Timestamptz `json:"month_end"`
	CommunityID pgtype.UUID        `json:"community_id"`
}

type GetCalendarEventsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Title               string             `json:"title"`
	EventType           EventType          `json:"event_type"`
	Status              NullEventStatus    `json:"status"`
	StartTime           pgtype.Timestamptz `json:"start_time"`
	EndTime             pgtype.Timestamptz `json:"end_time"`
	CommunityID         pgtype.UUID        `json:"community_id"`
	LocationName        pgtype.Text        `json:"location_name"`
	CurrentParticipants pgtype.Int4        `json:"current_participants"`
	MaxParticipants     pgtype.Int4        `json:"max_participants"`
}

func (q *Queries) GetCalendarEvents(ctx context.Context, arg GetCalendarEventsParams) ([]GetCalendarEventsRow, error) {
	rows, err := q.db.Query(ctx, getCalendarEvents, arg.MonthStart, arg.MonthEnd, arg.CommunityID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCalendarEventsRow{}
	for rows.Next() {
		var i GetCalendarEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.EventType,
			&i.Status,
			&i.StartTime,
			&i.EndTime,
			&i.CommunityID,
			&i.LocationName,
			&i.CurrentParticipants,
			&i.MaxParticipants,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, title, description, event_type, status,
    community_id, player_composition, match_format, match_format_details,
    tournament_system, tournament_details,
    court_id, location_name, location_address,
    start_time, end_time,
    max_participants, min_participants, current_participants,
    min_level, max_level,
    gender_restriction, min_age, max_age,
    registration_deadline,
    is_paid, price_amount, price_currency,
    created_by, created_at, updated_at
FROM events
WHERE id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id pgtype.UUID) (Event, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.EventType,
		&i.Status,
		&i.CommunityID,
		&i.PlayerComposition,
		&i.MatchFormat,
		&i.MatchFormatDetails,
		&i.TournamentSystem,
		&i.TournamentDetails,
		&i.CourtID,
		&i.LocationName,
		&i.LocationAddress,
		&i.StartTime,
		&i.EndTime,
		&i.MaxParticipants,
		&i.MinParticipants,
		&i.CurrentParticipants,
		&i.MinLevel,
		&i.MaxLevel,
		&i.GenderRestriction,
		&i.MinAge,
		&i.MaxAge,
		&i.RegistrationDeadline,
		&i.IsPaid,
		&i.PriceAmount,
		&i.PriceCurrency,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventParticipant = `-- name: GetEventParticipant :one
SELECT id, event_id, user_id, status, registered_at, cancelled_at, partner_id, seed_number
FROM event_participants
WHERE event_id = $1 AND user_id = $2
`

type GetEventParticipantParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetEventParticipant(ctx context.Context, arg GetEventParticipantParams) (EventParticipant, error) {
	row := q.db.QueryRow(ctx, getEventParticipant, arg.EventID, arg.UserID)
	var i EventParticipant
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.UserID,
		&i.Status,
		&i.RegisteredAt,
		&i.CancelledAt,
		&i.PartnerID,
		&i.SeedNumber,
	)
	return i, err
}

const getUserBadges = `-- name: GetUserBadges :many
SELECT ub.badge_id, ub.earned_at,
    bd.name_ru, bd.name_kz, bd.name_en,
    bd.description_ru, bd.icon, bd.condition_type, bd.condition_value
FROM user_badges ub
JOIN badge_definitions bd ON ub.badge_id = bd.id
WHERE ub.user_id = $1
ORDER BY ub.earned_at DESC
`

type GetUserBadgesRow struct {
	BadgeID        string             `json:"badge_id"`
	EarnedAt       pgtype.Timestamptz `json:"earned_at"`
	NameRu         string             `json:"name_ru"`
	NameKz         pgtype.Text        `json:"name_kz"`
	NameEn         pgtype.Text        `json:"name_en"`
	DescriptionRu  pgtype.Text        `json:"description_ru"`
	Icon           pgtype.Text        `json:"icon"`
	ConditionType  string             `json:"condition_type"`
	ConditionValue int32              `json:"condition_value"`
}

func (q *Queries) GetUserBadges(ctx context.Context, userID pgtype.UUID) ([]GetUserBadgesRow, error) {
	rows, err := q.db.Query(ctx, getUserBadges, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserBadgesRow{}
	for rows.Next() {
		var i GetUserBadgesRow
		if err := rows.Scan(
			&i.BadgeID,
			&i.EarnedAt,
			&i.NameRu,
			&i.NameKz,
			&i.NameEn,
			&i.DescriptionRu,
			&i.Icon,
			&i.ConditionType,
			&i.ConditionValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCommunities = `-- name: GetUserCommunities :many
SELECT c.id, c.name, c.slug, c.logo_url, c.community_type,
    cm.role, cm.status
FROM community_members cm
JOIN communities c ON cm.community_id = c.id
WHERE cm.user_id = $1 AND cm.status = 'active' AND c.is_active = TRUE
ORDER BY cm.joined_at DESC
`

type GetUserCommunitiesRow struct {
	ID            pgtype.UUID       `json:"id"`
	Name          string            `json:"name"`
	Slug          pgtype.Text       `json:"slug"`
	LogoUrl       pgtype.Text       `json:"logo_url"`
	CommunityType CommunityType     `json:"community_type"`
	Role          NullCommunityRole `json:"role"`
	Status        NullMemberStatus  `json:"status"`
}

func (q *Queries) GetUserCommunities(ctx context.Context, userID pgtype.UUID) ([]GetUserCommunitiesRow, error) {
	rows, err := q.db.Query(ctx, getUserCommunities, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCommunitiesRow{}
	for rows.Next() {
		var i GetUserCommunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.LogoUrl,
			&i.CommunityType,
			&i.Role,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one
SELECT user_id, total_games, total_wins, total_losses, win_rate,
    singles_games, singles_wins, doubles_games, doubles_wins,
    current_streak, best_streak, tournaments_played,
    last_game_at, updated_at
FROM player_stats_global
WHERE user_id = $1
`

func (q *Queries) GetUserStats(ctx context.Context, userID pgtype.UUID) (PlayerStatsGlobal, error) {
	row := q.db.QueryRow(ctx, getUserStats, userID)
	var i PlayerStatsGlobal
	err := row.Scan(
		&i.UserID,
		&i.TotalGames,
		&i.TotalWins,
		&i.TotalLosses,
		&i.WinRate,
		&i.SinglesGames,
		&i.SinglesWins,
		&i.DoublesGames,
		&i.DoublesWins,
		&i.CurrentStreak,
		&i.BestStreak,
		&i.TournamentsPlayed,
		&i.LastGameAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listEventParticipants = `-- name: ListEventParticipants :many
SELECT ep.id, ep.event_id, ep.user_id, ep.status, ep.registered_at, ep.partner_id, ep.seed_number,
    u.first_name, u.last_name, u.avatar_url, u.ntrp_level, u.global_rating
FROM event_participants ep
JOIN users u ON ep.user_id = u.id
WHERE ep.event_id = $1 AND ep.status IN ('registered', 'confirmed', 'checked_in')
ORDER BY ep.registered_at ASC
`

type ListEventParticipantsRow struct {
	ID           pgtype.UUID           `json:"id"`
	EventID      pgtype.UUID           `json:"event_id"`
	UserID       pgtype.UUID           `json:"user_id"`
	Status       NullParticipantStatus `json:"status"`
	RegisteredAt pgtype.Timestamptz    `json:"registered_at"`
	PartnerID    pgtype.UUID           `json:"partner_id"`
	SeedNumber   pgtype.Int4           `json:"seed_number"`
	FirstName    pgtype.Text           `json:"first_name"`
	LastName     pgtype.Text           `json:"last_name"`
	AvatarUrl    pgtype.Text           `json:"avatar_url"`
	NtrpLevel    pgtype.Numeric        `json:"ntrp_level"`
	GlobalRating pgtype.Numeric        `json:"global_rating"`
}

func (q *Queries) ListEventParticipants(ctx context.Context, eventID pgtype.UUID) ([]ListEventParticipantsRow, error) {
	rows, err := q.db.Query(ctx, listEventParticipants, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventParticipantsRow{}
	for rows.Next() {
		var i ListEventParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.UserID,
			&i.Status,
			&i.RegisteredAt,
			&i.PartnerID,
			&i.SeedNumber,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.NtrpLevel,
			&i.GlobalRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEvents = `-- name: ListEvents :many
SELECT id, title, description, event_type, status,
    community_id, player_composition, match_format,
    court_id, location_name, location_address,
    start_time, end_time,
    max_participants, min_participants, current_participants,
    min_level, max_level,
    gender_restriction, registration_deadline,
    is_paid, price_amount, price_currency,
    created_by, created_at
FROM events
WHERE ($1::event_type IS NULL OR event_type = $1)
  AND ($2::event_status IS NULL OR status = $2)
  AND ($3::player_composition IS NULL OR player_composition = $3)
  AND ($4::uuid IS NULL OR community_id = $4)
  AND ($5::decimal IS NULL OR max_level >= $5)
  AND ($6::decimal IS NULL OR min_level <= $6)
  AND ($7::timestamptz IS NULL OR start_time >= $7)
  AND ($8::timestamptz IS NULL OR start_time <= $8)
  AND ($9::text IS NULL OR location_address ILIKE '%' || $9 || '%')
  AND status NOT IN ('draft', 'cancelled', 'archived')
ORDER BY
    CASE WHEN $10::text = 'date_asc' THEN start_time END ASC,
    CASE WHEN $10::text = 'spots_left' THEN (max_participants - current_participants) END DESC,
    start_time DESC
LIMIT $12 OFFSET $11
`

type ListEventsParams struct {
	EventType    NullEventType         `json:"event_type"`
	EventStatus  NullEventStatus       `json:"event_status"`
	Composition  NullPlayerComposition `json:"composition"`
	CommunityID  pgtype.UUID           `json:"community_id"`
	MinLevel     pgtype.Numeric        `json:"min_level"`
	MaxLevel     pgtype.Numeric        `json:"max_level"`
	DateFrom     pgtype.Timestamptz    `json:"date_from"`
	DateTo       pgtype.Timestamptz    `json:"date_to"`
	District     pgtype.Text           `json:"district"`
	SortBy       string                `json:"sort_by"`
	ResultOffset int32                 `json:"result_offset"`
	ResultLimit  int32                 `json:"result_limit"`
}

type ListEventsRow struct {
	ID                   pgtype.UUID        `json:"id"`
	Title                string             `json:"title"`
	Description          pgtype.Text        `json:"description"`
	EventType            EventType          `json:"event_type"`
	Status               NullEventStatus    `json:"status"`
	CommunityID          pgtype.UUID        `json:"community_id"`
	PlayerComposition    PlayerComposition  `json:"player_composition"`
	MatchFormat          NullMatchFormat    `json:"match_format"`
	CourtID              pgtype.UUID        `json:"court_id"`
	LocationName         pgtype.Text        `json:"location_name"`
	LocationAddress      pgtype.Text        `json:"location_address"`
	StartTime            pgtype.Timestamptz `json:"start_time"`
	EndTime              pgtype.Timestamptz `json:"end_time"`
	MaxParticipants      pgtype.Int4        `json:"max_participants"`
	MinParticipants      pgtype.Int4        `json:"min_participants"`
	CurrentParticipants  pgtype.Int4        `json:"current_participants"`
	MinLevel             pgtype.Numeric     `json:"min_level"`
	MaxLevel             pgtype.Numeric     `json:"max_level"`
	GenderRestriction    NullGenderType     `json:"gender_restriction"`
	RegistrationDeadline pgtype.Timestamptz `json:"registration_deadline"`
	IsPaid               pgtype.Bool        `json:"is_paid"`
	PriceAmount          pgtype.Numeric     `json:"price_amount"`
	PriceCurrency        pgtype.Text        `json:"price_currency"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListEvents(ctx context.Context, arg ListEventsParams) ([]ListEventsRow, error) {
	rows, err := q.db.Query(ctx, listEvents,
		arg.EventType,
		arg.EventStatus,
		arg.Composition,
		arg.CommunityID,
		arg.MinLevel,
		arg.MaxLevel,
		arg.DateFrom,
		arg.DateTo,
		arg.District,
		arg.SortBy,
		arg.ResultOffset,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListEventsRow{}
	for rows.Next() {
		var i ListEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.EventType,
			&i.Status,
			&i.CommunityID,
			&i.PlayerComposition,
			&i.MatchFormat,
			&i.CourtID,
			&i.LocationName,
			&i.LocationAddress,
			&i.StartTime,
			&i.EndTime,
			&i.MaxParticipants,
			&i.MinParticipants,
			&i.CurrentParticipants,
			&i.MinLevel,
			&i.MaxLevel,
			&i.GenderRestriction,
			&i.RegistrationDeadline,
			&i.IsPaid,
			&i.PriceAmount,
			&i.PriceCurrency,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyCreatedEvents = `-- name: ListMyCreatedEvents :many
SELECT id, title, description, event_type, status,
    community_id, start_time, end_time,
    max_participants, current_participants,
    min_level, max_level, location_name,
    created_by, created_at
FROM events
WHERE created_by = $1
ORDER BY start_time DESC
LIMIT $2 OFFSET $3
`

type ListMyCreatedEventsParams struct {
	CreatedBy pgtype.UUID `json:"created_by"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

type ListMyCreatedEventsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Title               string             `json:"title"`
	Description         pgtype.Text        `json:"description"`
	EventType           EventType          `json:"event_type"`
	Status              NullEventStatus    `json:"status"`
	CommunityID         pgtype.UUID        `json:"community_id"`
	StartTime           pgtype.Timestamptz `json:"start_time"`
	EndTime             pgtype.Timestamptz `json:"end_time"`
	MaxParticipants     pgtype.Int4        `json:"max_participants"`
	CurrentParticipants pgtype.Int4        `json:"current_participants"`
	MinLevel            pgtype.Numeric     `json:"min_level"`
	MaxLevel            pgtype.Numeric     `json:"max_level"`
	LocationName        pgtype.Text        `json:"location_name"`
	CreatedBy           pgtype.UUID        `json:"created_by"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListMyCreatedEvents(ctx context.Context, arg ListMyCreatedEventsParams) ([]ListMyCreatedEventsRow, error) {
	rows, err := q.db.Query(ctx, listMyCreatedEvents, arg.CreatedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMyCreatedEventsRow{}
	for rows.Next() {
		var i ListMyCreatedEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.EventType,
			&i.Status,
			&i.CommunityID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxParticipants,
			&i.CurrentParticipants,
			&i.MinLevel,
			&i.MaxLevel,
			&i.LocationName,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyJoinedEvents = `-- name: ListMyJoinedEvents :many
SELECT e.id, e.title, e.description, e.event_type, e.status,
    e.community_id, e.start_time, e.end_time,
    e.max_participants, e.current_participants,
    e.min_level, e.max_level, e.location_name,
    e.created_by, e.created_at
FROM events e
JOIN event_participants ep ON e.id = ep.event_id
WHERE ep.user_id = $1
  AND ep.status IN ('registered', 'confirmed', 'checked_in')
  AND e.status NOT IN ('completed', 'cancelled', 'archived')
ORDER BY e.start_time ASC
LIMIT $2 OFFSET $3
`

type ListMyJoinedEventsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListMyJoinedEventsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Title               string             `json:"title"`
	Description         pgtype.Text        `json:"description"`
	EventType           EventType          `json:"event_type"`
	Status              NullEventStatus    `json:"status"`
	CommunityID         pgtype.UUID        `json:"community_id"`
	StartTime           pgtype.Timestamptz `json:"start_time"`
	EndTime             pgtype.Timestamptz `json:"end_time"`
	MaxParticipants     pgtype.Int4        `json:"max_participants"`
	CurrentParticipants pgtype.Int4        `json:"current_participants"`
	MinLevel            pgtype.Numeric     `json:"min_level"`
	MaxLevel            pgtype.Numeric     `json:"max_level"`
	LocationName        pgtype.Text        `json:"location_name"`
	CreatedBy           pgtype.UUID        `json:"created_by"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListMyJoinedEvents(ctx context.Context, arg ListMyJoinedEventsParams) ([]ListMyJoinedEventsRow, error) {
	rows, err := q.db.Query(ctx, listMyJoinedEvents, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMyJoinedEventsRow{}
	for rows.Next() {
		var i ListMyJoinedEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.EventType,
			&i.Status,
			&i.CommunityID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxParticipants,
			&i.CurrentParticipants,
			&i.MinLevel,
			&i.MaxLevel,
			&i.LocationName,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyPastEvents = `-- name: ListMyPastEvents :many
SELECT e.id, e.title, e.description, e.event_type, e.status,
    e.community_id, e.start_time, e.end_time,
    e.max_participants, e.current_participants,
    e.min_level, e.max_level, e.location_name,
    e.created_by, e.created_at
FROM events e
JOIN event_participants ep ON e.id = ep.event_id
WHERE ep.user_id = $1
  AND e.status IN ('completed', 'cancelled', 'archived')
ORDER BY e.start_time DESC
LIMIT $2 OFFSET $3
`

type ListMyPastEventsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

type ListMyPastEventsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	Title               string             `json:"title"`
	Description         pgtype.Text        `json:"description"`
	EventType           EventType          `json:"event_type"`
	Status              NullEventStatus    `json:"status"`
	CommunityID         pgtype.UUID        `json:"community_id"`
	StartTime           pgtype.Timestamptz `json:"start_time"`
	EndTime             pgtype.Timestamptz `json:"end_time"`
	MaxParticipants     pgtype.Int4        `json:"max_participants"`
	CurrentParticipants pgtype.Int4        `json:"current_participants"`
	MinLevel            pgtype.Numeric     `json:"min_level"`
	MaxLevel            pgtype.Numeric     `json:"max_level"`
	LocationName        pgtype.Text        `json:"location_name"`
	CreatedBy           pgtype.UUID        `json:"created_by"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
}

func (q *Queries) ListMyPastEvents(ctx context.Context, arg ListMyPastEventsParams) ([]ListMyPastEventsRow, error) {
	rows, err := q.db.Query(ctx, listMyPastEvents, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMyPastEventsRow{}
	for rows.Next() {
		var i ListMyPastEventsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.EventType,
			&i.Status,
			&i.CommunityID,
			&i.StartTime,
			&i.EndTime,
			&i.MaxParticipants,
			&i.CurrentParticipants,
			&i.MinLevel,
			&i.MaxLevel,
			&i.LocationName,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeEventParticipant = `-- name: RemoveEventParticipant :exec
DELETE FROM event_participants
WHERE event_id = $1 AND user_id = $2
`

type RemoveEventParticipantParams struct {
	EventID pgtype.UUID `json:"event_id"`
	UserID  pgtype.UUID `json:"user_id"`
}

func (q *Queries) RemoveEventParticipant(ctx context.Context, arg RemoveEventParticipantParams) error {
	_, err := q.db.Exec(ctx, removeEventParticipant, arg.EventID, arg.UserID)
	return err
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events SET
    title              = COALESCE($1, title),
    description        = COALESCE($2, description),
    start_time         = COALESCE($3, start_time),
    end_time           = COALESCE($4, end_time),
    max_participants   = COALESCE($5, max_participants),
    min_level          = COALESCE($6, min_level),
    max_level          = COALESCE($7, max_level),
    registration_deadline = COALESCE($8, registration_deadline),
    updated_at         = NOW()
WHERE id = $9
RETURNING id, title, description, event_type, status,
    community_id, player_composition, match_format, match_format_details,
    court_id, location_name, location_address,
    start_time, end_time,
    max_participants, min_participants, current_participants,
    min_level, max_level,
    gender_restriction, registration_deadline,
    is_paid, price_amount, price_currency,
    created_by, created_at, updated_at
`

type UpdateEventParams struct {
	Title                pgtype.Text        `json:"title"`
	Description          pgtype.Text        `json:"description"`
	StartTime            pgtype.Timestamptz `json:"start_time"`
	EndTime              pgtype.Timestamptz `json:"end_time"`
	MaxParticipants      pgtype.Int4        `json:"max_participants"`
	MinLevel             pgtype.Numeric     `json:"min_level"`
	MaxLevel             pgtype.Numeric     `json:"max_level"`
	RegistrationDeadline pgtype.Timestamptz `json:"registration_deadline"`
	ID                   pgtype.UUID        `json:"id"`
}

type UpdateEventRow struct {
	ID                   pgtype.UUID        `json:"id"`
	Title                string             `json:"title"`
	Description          pgtype.Text        `json:"description"`
	EventType            EventType          `json:"event_type"`
	Status               NullEventStatus    `json:"status"`
	CommunityID          pgtype.UUID        `json:"community_id"`
	PlayerComposition    PlayerComposition  `json:"player_composition"`
	MatchFormat          NullMatchFormat    `json:"match_format"`
	MatchFormatDetails   []byte             `json:"match_format_details"`
	CourtID              pgtype.UUID        `json:"court_id"`
	LocationName         pgtype.Text        `json:"location_name"`
	LocationAddress      pgtype.Text        `json:"location_address"`
	StartTime            pgtype.Timestamptz `json:"start_time"`
	EndTime              pgtype.Timestamptz `json:"end_time"`
	MaxParticipants      pgtype.Int4        `json:"max_participants"`
	MinParticipants      pgtype.Int4        `json:"min_participants"`
	CurrentParticipants  pgtype.Int4        `json:"current_participants"`
	MinLevel             pgtype.Numeric     `json:"min_level"`
	MaxLevel             pgtype.Numeric     `json:"max_level"`
	GenderRestriction    NullGenderType     `json:"gender_restriction"`
	RegistrationDeadline pgtype.Timestamptz `json:"registration_deadline"`
	IsPaid               pgtype.Bool        `json:"is_paid"`
	PriceAmount          pgtype.Numeric     `json:"price_amount"`
	PriceCurrency        pgtype.Text        `json:"price_currency"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (UpdateEventRow, error) {
	row := q.db.QueryRow(ctx, updateEvent,
		arg.Title,
		arg.Description,
		arg.StartTime,
		arg.EndTime,
		arg.MaxParticipants,
		arg.MinLevel,
		arg.MaxLevel,
		arg.RegistrationDeadline,
		arg.ID,
	)
	var i UpdateEventRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.EventType,
		&i.Status,
		&i.CommunityID,
		&i.PlayerComposition,
		&i.MatchFormat,
		&i.MatchFormatDetails,
		&i.CourtID,
		&i.LocationName,
		&i.LocationAddress,
		&i.StartTime,
		&i.EndTime,
		&i.MaxParticipants,
		&i.MinParticipants,
		&i.CurrentParticipants,
		&i.MinLevel,
		&i.MaxLevel,
		&i.GenderRestriction,
		&i.RegistrationDeadline,
		&i.IsPaid,
		&i.PriceAmount,
		&i.PriceCurrency,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateEventStatus = `-- name: UpdateEventStatus :one
UPDATE events SET
    status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, title, description, event_type, status,
    community_id, player_composition, match_format, match_format_details,
    court_id, location_name, location_address,
    start_time, end_time,
    max_participants, min_participants, current_participants,
    min_level, max_level,
    gender_restriction, registration_deadline,
    is_paid, price_amount, price_currency,
    created_by, created_at, updated_at
`

type UpdateEventStatusParams struct {
	ID     pgtype.UUID     `json:"id"`
	Status NullEventStatus `json:"status"`
}

type UpdateEventStatusRow struct {
	ID                   pgtype.UUID        `json:"id"`
	Title                string             `json:"title"`
	Description          pgtype.Text        `json:"description"`
	EventType            EventType          `json:"event_type"`
	Status               NullEventStatus    `json:"status"`
	CommunityID          pgtype.UUID        `json:"community_id"`
	PlayerComposition    PlayerComposition  `json:"player_composition"`
	MatchFormat          NullMatchFormat    `json:"match_format"`
	MatchFormatDetails   []byte             `json:"match_format_details"`
	CourtID              pgtype.UUID        `json:"court_id"`
	LocationName         pgtype.Text        `json:"location_name"`
	LocationAddress      pgtype.Text        `json:"location_address"`
	StartTime            pgtype.Timestamptz `json:"start_time"`
	EndTime              pgtype.Timestamptz `json:"end_time"`
	MaxParticipants      pgtype.Int4        `json:"max_participants"`
	MinParticipants      pgtype.Int4        `json:"min_participants"`
	CurrentParticipants  pgtype.Int4        `json:"current_participants"`
	MinLevel             pgtype.Numeric     `json:"min_level"`
	MaxLevel             pgtype.Numeric     `json:"max_level"`
	GenderRestriction    NullGenderType     `json:"gender_restriction"`
	RegistrationDeadline pgtype.Timestamptz `json:"registration_deadline"`
	IsPaid               pgtype.Bool        `json:"is_paid"`
	PriceAmount          pgtype.Numeric     `json:"price_amount"`
	PriceCurrency        pgtype.Text        `json:"price_currency"`
	CreatedBy            pgtype.UUID        `json:"created_by"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateEventStatus(ctx context.Context, arg UpdateEventStatusParams) (UpdateEventStatusRow, error) {
	row := q.db.QueryRow(ctx, updateEventStatus, arg.ID, arg.Status)
	var i UpdateEventStatusRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.EventType,
		&i.Status,
		&i.CommunityID,
		&i.PlayerComposition,
		&i.MatchFormat,
		&i.MatchFormatDetails,
		&i.CourtID,
		&i.LocationName,
		&i.LocationAddress,
		&i.StartTime,
		&i.EndTime,
		&i.MaxParticipants,
		&i.MinParticipants,
		&i.CurrentParticipants,
		&i.MinLevel,
		&i.MaxLevel,
		&i.GenderRestriction,
		&i.RegistrationDeadline,
		&i.IsPaid,
		&i.PriceAmount,
		&i.PriceCurrency,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserAvatarURL = `-- name: UpdateUserAvatarURL :one
UPDATE users SET
    avatar_url = $2,
    updated_at = NOW()
WHERE id = $1 AND status != 'deleted'
RETURNING id, avatar_url
`

type UpdateUserAvatarURLParams struct {
	ID        pgtype.UUID `json:"id"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

type UpdateUserAvatarURLRow struct {
	ID        pgtype.UUID `json:"id"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) UpdateUserAvatarURL(ctx context.Context, arg UpdateUserAvatarURLParams) (UpdateUserAvatarURLRow, error) {
	row := q.db.QueryRow(ctx, updateUserAvatarURL, arg.ID, arg.AvatarUrl)
	var i UpdateUserAvatarURLRow
	err := row.Scan(&i.ID, &i.AvatarUrl)
	return i, err
}
