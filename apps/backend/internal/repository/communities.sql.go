// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: communities.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addCommunityMember = `-- name: AddCommunityMember :one
INSERT INTO community_members (
    community_id, user_id, role, status, application_message
) VALUES (
    $1, $2, $3, $4, $5
)
RETURNING id, community_id, user_id, role, status, application_message,
    reviewed_by, reviewed_at,
    community_rating, community_games_count, community_wins, community_losses,
    joined_at, updated_at
`

type AddCommunityMemberParams struct {
	CommunityID        pgtype.UUID       `json:"community_id"`
	UserID             pgtype.UUID       `json:"user_id"`
	Role               NullCommunityRole `json:"role"`
	Status             NullMemberStatus  `json:"status"`
	ApplicationMessage pgtype.Text       `json:"application_message"`
}

func (q *Queries) AddCommunityMember(ctx context.Context, arg AddCommunityMemberParams) (CommunityMember, error) {
	row := q.db.QueryRow(ctx, addCommunityMember,
		arg.CommunityID,
		arg.UserID,
		arg.Role,
		arg.Status,
		arg.ApplicationMessage,
	)
	var i CommunityMember
	err := row.Scan(
		&i.ID,
		&i.CommunityID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.ApplicationMessage,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CommunityRating,
		&i.CommunityGamesCount,
		&i.CommunityWins,
		&i.CommunityLosses,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countCommunities = `-- name: CountCommunities :one
SELECT COUNT(*)
FROM communities
WHERE is_active = TRUE
  AND ($1::community_type IS NULL OR community_type = $1)
  AND ($2::community_access IS NULL OR access_level = $2)
  AND ($3::boolean IS NULL OR ($3::boolean = FALSE) OR verification_status = 'verified')
  AND ($4::text IS NULL OR district = $4)
  AND ($5::text IS NULL OR name ILIKE '%' || $5 || '%')
`

type CountCommunitiesParams struct {
	CommunityType NullCommunityType   `json:"community_type"`
	AccessLevel   NullCommunityAccess `json:"access_level"`
	VerifiedOnly  pgtype.Bool         `json:"verified_only"`
	District      pgtype.Text         `json:"district"`
	Query         pgtype.Text         `json:"query"`
}

func (q *Queries) CountCommunities(ctx context.Context, arg CountCommunitiesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCommunities,
		arg.CommunityType,
		arg.AccessLevel,
		arg.VerifiedOnly,
		arg.District,
		arg.Query,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countCommunityMembers = `-- name: CountCommunityMembers :one
SELECT COUNT(*)
FROM community_members cm
JOIN users u ON cm.user_id = u.id
WHERE cm.community_id = $1
  AND ($2::community_role IS NULL OR cm.role = $2)
  AND ($3::member_status IS NULL OR cm.status = $3)
  AND ($4::text IS NULL OR (u.first_name || ' ' || u.last_name) ILIKE '%' || $4 || '%')
`

type CountCommunityMembersParams struct {
	CommunityID  pgtype.UUID       `json:"community_id"`
	MemberRole   NullCommunityRole `json:"member_role"`
	MemberStatus NullMemberStatus  `json:"member_status"`
	Query        pgtype.Text       `json:"query"`
}

func (q *Queries) CountCommunityMembers(ctx context.Context, arg CountCommunityMembersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countCommunityMembers,
		arg.CommunityID,
		arg.MemberRole,
		arg.MemberStatus,
		arg.Query,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCommunity = `-- name: CreateCommunity :one
INSERT INTO communities (
    name, slug, description, community_type, access_level,
    verification_status, district, created_by
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
)
RETURNING id, name, slug, description, rules, community_type, access_level,
    verification_status, verified_at, verification_documents,
    logo_url, banner_url, contact_phone, contact_email, social_links,
    address, district,
    rating_initial, rating_k_factor, rating_min_games,
    member_count, event_count, is_active,
    created_by, created_at, updated_at
`

type CreateCommunityParams struct {
	Name               string                 `json:"name"`
	Slug               pgtype.Text            `json:"slug"`
	Description        pgtype.Text            `json:"description"`
	CommunityType      CommunityType          `json:"community_type"`
	AccessLevel        NullCommunityAccess    `json:"access_level"`
	VerificationStatus NullVerificationStatus `json:"verification_status"`
	District           pgtype.Text            `json:"district"`
	CreatedBy          pgtype.UUID            `json:"created_by"`
}

func (q *Queries) CreateCommunity(ctx context.Context, arg CreateCommunityParams) (Community, error) {
	row := q.db.QueryRow(ctx, createCommunity,
		arg.Name,
		arg.Slug,
		arg.Description,
		arg.CommunityType,
		arg.AccessLevel,
		arg.VerificationStatus,
		arg.District,
		arg.CreatedBy,
	)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Rules,
		&i.CommunityType,
		&i.AccessLevel,
		&i.VerificationStatus,
		&i.VerifiedAt,
		&i.VerificationDocuments,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.SocialLinks,
		&i.Address,
		&i.District,
		&i.RatingInitial,
		&i.RatingKFactor,
		&i.RatingMinGames,
		&i.MemberCount,
		&i.EventCount,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteCommunityMember = `-- name: DeleteCommunityMember :exec
DELETE FROM community_members
WHERE community_id = $1 AND user_id = $2
`

type DeleteCommunityMemberParams struct {
	CommunityID pgtype.UUID `json:"community_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteCommunityMember(ctx context.Context, arg DeleteCommunityMemberParams) error {
	_, err := q.db.Exec(ctx, deleteCommunityMember, arg.CommunityID, arg.UserID)
	return err
}

const getCommunityByID = `-- name: GetCommunityByID :one
SELECT id, name, slug, description, rules, community_type, access_level,
    verification_status, verified_at, verification_documents,
    logo_url, banner_url, contact_phone, contact_email, social_links,
    address, district,
    rating_initial, rating_k_factor, rating_min_games,
    member_count, event_count, is_active,
    created_by, created_at, updated_at
FROM communities
WHERE id = $1 AND is_active = TRUE
`

func (q *Queries) GetCommunityByID(ctx context.Context, id pgtype.UUID) (Community, error) {
	row := q.db.QueryRow(ctx, getCommunityByID, id)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Rules,
		&i.CommunityType,
		&i.AccessLevel,
		&i.VerificationStatus,
		&i.VerifiedAt,
		&i.VerificationDocuments,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.SocialLinks,
		&i.Address,
		&i.District,
		&i.RatingInitial,
		&i.RatingKFactor,
		&i.RatingMinGames,
		&i.MemberCount,
		&i.EventCount,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCommunityBySlug = `-- name: GetCommunityBySlug :one
SELECT id, name, slug, description, rules, community_type, access_level,
    verification_status, verified_at, verification_documents,
    logo_url, banner_url, contact_phone, contact_email, social_links,
    address, district,
    rating_initial, rating_k_factor, rating_min_games,
    member_count, event_count, is_active,
    created_by, created_at, updated_at
FROM communities
WHERE slug = $1 AND is_active = TRUE
`

func (q *Queries) GetCommunityBySlug(ctx context.Context, slug pgtype.Text) (Community, error) {
	row := q.db.QueryRow(ctx, getCommunityBySlug, slug)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Rules,
		&i.CommunityType,
		&i.AccessLevel,
		&i.VerificationStatus,
		&i.VerifiedAt,
		&i.VerificationDocuments,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.SocialLinks,
		&i.Address,
		&i.District,
		&i.RatingInitial,
		&i.RatingKFactor,
		&i.RatingMinGames,
		&i.MemberCount,
		&i.EventCount,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCommunityLeaderboard = `-- name: GetCommunityLeaderboard :many
SELECT
    cm.user_id,
    u.first_name, u.last_name, u.avatar_url, u.ntrp_level,
    cm.community_rating,
    cm.community_games_count,
    cm.community_wins,
    cm.community_losses,
    CASE WHEN cm.community_games_count > 0
        THEN ROUND(cm.community_wins::decimal / cm.community_games_count * 100, 1)
        ELSE 0
    END as win_rate
FROM community_members cm
JOIN users u ON cm.user_id = u.id
WHERE cm.community_id = $1 AND cm.status = 'active' AND u.status = 'active'
  AND cm.community_games_count >= $2
ORDER BY cm.community_rating DESC
LIMIT $3 OFFSET $4
`

type GetCommunityLeaderboardParams struct {
	CommunityID         pgtype.UUID `json:"community_id"`
	CommunityGamesCount pgtype.Int4 `json:"community_games_count"`
	Limit               int32       `json:"limit"`
	Offset              int32       `json:"offset"`
}

type GetCommunityLeaderboardRow struct {
	UserID              pgtype.UUID    `json:"user_id"`
	FirstName           pgtype.Text    `json:"first_name"`
	LastName            pgtype.Text    `json:"last_name"`
	AvatarUrl           pgtype.Text    `json:"avatar_url"`
	NtrpLevel           pgtype.Numeric `json:"ntrp_level"`
	CommunityRating     pgtype.Numeric `json:"community_rating"`
	CommunityGamesCount pgtype.Int4    `json:"community_games_count"`
	CommunityWins       pgtype.Int4    `json:"community_wins"`
	CommunityLosses     pgtype.Int4    `json:"community_losses"`
	WinRate             int32          `json:"win_rate"`
}

func (q *Queries) GetCommunityLeaderboard(ctx context.Context, arg GetCommunityLeaderboardParams) ([]GetCommunityLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getCommunityLeaderboard,
		arg.CommunityID,
		arg.CommunityGamesCount,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetCommunityLeaderboardRow{}
	for rows.Next() {
		var i GetCommunityLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.NtrpLevel,
			&i.CommunityRating,
			&i.CommunityGamesCount,
			&i.CommunityWins,
			&i.CommunityLosses,
			&i.WinRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityMember = `-- name: GetCommunityMember :one
SELECT id, community_id, user_id, role, status, application_message,
    reviewed_by, reviewed_at,
    community_rating, community_games_count, community_wins, community_losses,
    joined_at, updated_at
FROM community_members
WHERE community_id = $1 AND user_id = $2
`

type GetCommunityMemberParams struct {
	CommunityID pgtype.UUID `json:"community_id"`
	UserID      pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetCommunityMember(ctx context.Context, arg GetCommunityMemberParams) (CommunityMember, error) {
	row := q.db.QueryRow(ctx, getCommunityMember, arg.CommunityID, arg.UserID)
	var i CommunityMember
	err := row.Scan(
		&i.ID,
		&i.CommunityID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.ApplicationMessage,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CommunityRating,
		&i.CommunityGamesCount,
		&i.CommunityWins,
		&i.CommunityLosses,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCommunities = `-- name: ListCommunities :many
SELECT id, name, slug, description, community_type, access_level,
    verification_status, logo_url, district,
    member_count, event_count, is_active,
    created_by, created_at
FROM communities
WHERE is_active = TRUE
  AND ($1::community_type IS NULL OR community_type = $1)
  AND ($2::community_access IS NULL OR access_level = $2)
  AND ($3::boolean IS NULL OR ($3::boolean = FALSE) OR verification_status = 'verified')
  AND ($4::text IS NULL OR district = $4)
  AND ($5::text IS NULL OR name ILIKE '%' || $5 || '%')
ORDER BY
    CASE WHEN $6::text = 'members' THEN member_count END DESC,
    CASE WHEN $6::text = 'activity' THEN event_count END DESC,
    CASE WHEN $6::text = 'name' THEN 1 END ASC,
    CASE WHEN $6::text = 'created' THEN 1 END ASC,
    created_at DESC
LIMIT $8 OFFSET $7
`

type ListCommunitiesParams struct {
	CommunityType NullCommunityType   `json:"community_type"`
	AccessLevel   NullCommunityAccess `json:"access_level"`
	VerifiedOnly  pgtype.Bool         `json:"verified_only"`
	District      pgtype.Text         `json:"district"`
	Query         pgtype.Text         `json:"query"`
	SortBy        string              `json:"sort_by"`
	ResultOffset  int32               `json:"result_offset"`
	ResultLimit   int32               `json:"result_limit"`
}

type ListCommunitiesRow struct {
	ID                 pgtype.UUID            `json:"id"`
	Name               string                 `json:"name"`
	Slug               pgtype.Text            `json:"slug"`
	Description        pgtype.Text            `json:"description"`
	CommunityType      CommunityType          `json:"community_type"`
	AccessLevel        NullCommunityAccess    `json:"access_level"`
	VerificationStatus NullVerificationStatus `json:"verification_status"`
	LogoUrl            pgtype.Text            `json:"logo_url"`
	District           pgtype.Text            `json:"district"`
	MemberCount        pgtype.Int4            `json:"member_count"`
	EventCount         pgtype.Int4            `json:"event_count"`
	IsActive           pgtype.Bool            `json:"is_active"`
	CreatedBy          pgtype.UUID            `json:"created_by"`
	CreatedAt          pgtype.Timestamptz     `json:"created_at"`
}

func (q *Queries) ListCommunities(ctx context.Context, arg ListCommunitiesParams) ([]ListCommunitiesRow, error) {
	rows, err := q.db.Query(ctx, listCommunities,
		arg.CommunityType,
		arg.AccessLevel,
		arg.VerifiedOnly,
		arg.District,
		arg.Query,
		arg.SortBy,
		arg.ResultOffset,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommunitiesRow{}
	for rows.Next() {
		var i ListCommunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CommunityType,
			&i.AccessLevel,
			&i.VerificationStatus,
			&i.LogoUrl,
			&i.District,
			&i.MemberCount,
			&i.EventCount,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCommunityMembers = `-- name: ListCommunityMembers :many
SELECT cm.id, cm.community_id, cm.user_id, cm.role, cm.status,
    cm.application_message, cm.reviewed_by, cm.reviewed_at,
    cm.community_rating, cm.community_games_count, cm.community_wins, cm.community_losses,
    cm.joined_at, cm.updated_at,
    u.first_name, u.last_name, u.avatar_url, u.ntrp_level, u.global_rating
FROM community_members cm
JOIN users u ON cm.user_id = u.id
WHERE cm.community_id = $1
  AND ($2::community_role IS NULL OR cm.role = $2)
  AND ($3::member_status IS NULL OR cm.status = $3)
  AND ($4::text IS NULL OR (u.first_name || ' ' || u.last_name) ILIKE '%' || $4 || '%')
ORDER BY
    CASE WHEN $5::text = 'rating' THEN cm.community_rating END DESC,
    CASE WHEN $5::text = 'name' THEN u.first_name END ASC,
    CASE WHEN $5::text = 'joined' THEN 1 END ASC,
    cm.joined_at DESC
LIMIT $7 OFFSET $6
`

type ListCommunityMembersParams struct {
	CommunityID  pgtype.UUID       `json:"community_id"`
	MemberRole   NullCommunityRole `json:"member_role"`
	MemberStatus NullMemberStatus  `json:"member_status"`
	Query        pgtype.Text       `json:"query"`
	SortBy       string            `json:"sort_by"`
	ResultOffset int32             `json:"result_offset"`
	ResultLimit  int32             `json:"result_limit"`
}

type ListCommunityMembersRow struct {
	ID                  pgtype.UUID        `json:"id"`
	CommunityID         pgtype.UUID        `json:"community_id"`
	UserID              pgtype.UUID        `json:"user_id"`
	Role                NullCommunityRole  `json:"role"`
	Status              NullMemberStatus   `json:"status"`
	ApplicationMessage  pgtype.Text        `json:"application_message"`
	ReviewedBy          pgtype.UUID        `json:"reviewed_by"`
	ReviewedAt          pgtype.Timestamptz `json:"reviewed_at"`
	CommunityRating     pgtype.Numeric     `json:"community_rating"`
	CommunityGamesCount pgtype.Int4        `json:"community_games_count"`
	CommunityWins       pgtype.Int4        `json:"community_wins"`
	CommunityLosses     pgtype.Int4        `json:"community_losses"`
	JoinedAt            pgtype.Timestamptz `json:"joined_at"`
	UpdatedAt           pgtype.Timestamptz `json:"updated_at"`
	FirstName           pgtype.Text        `json:"first_name"`
	LastName            pgtype.Text        `json:"last_name"`
	AvatarUrl           pgtype.Text        `json:"avatar_url"`
	NtrpLevel           pgtype.Numeric     `json:"ntrp_level"`
	GlobalRating        pgtype.Numeric     `json:"global_rating"`
}

func (q *Queries) ListCommunityMembers(ctx context.Context, arg ListCommunityMembersParams) ([]ListCommunityMembersRow, error) {
	rows, err := q.db.Query(ctx, listCommunityMembers,
		arg.CommunityID,
		arg.MemberRole,
		arg.MemberStatus,
		arg.Query,
		arg.SortBy,
		arg.ResultOffset,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListCommunityMembersRow{}
	for rows.Next() {
		var i ListCommunityMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.CommunityID,
			&i.UserID,
			&i.Role,
			&i.Status,
			&i.ApplicationMessage,
			&i.ReviewedBy,
			&i.ReviewedAt,
			&i.CommunityRating,
			&i.CommunityGamesCount,
			&i.CommunityWins,
			&i.CommunityLosses,
			&i.JoinedAt,
			&i.UpdatedAt,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.NtrpLevel,
			&i.GlobalRating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMyCommunities = `-- name: ListMyCommunities :many
SELECT c.id, c.name, c.slug, c.description, c.community_type, c.access_level,
    c.verification_status, c.logo_url, c.district,
    c.member_count, c.event_count, c.is_active,
    c.created_by, c.created_at,
    cm.role, cm.status as member_status
FROM communities c
JOIN community_members cm ON c.id = cm.community_id
WHERE cm.user_id = $1 AND cm.status = 'active' AND c.is_active = TRUE
ORDER BY cm.joined_at DESC
`

type ListMyCommunitiesRow struct {
	ID                 pgtype.UUID            `json:"id"`
	Name               string                 `json:"name"`
	Slug               pgtype.Text            `json:"slug"`
	Description        pgtype.Text            `json:"description"`
	CommunityType      CommunityType          `json:"community_type"`
	AccessLevel        NullCommunityAccess    `json:"access_level"`
	VerificationStatus NullVerificationStatus `json:"verification_status"`
	LogoUrl            pgtype.Text            `json:"logo_url"`
	District           pgtype.Text            `json:"district"`
	MemberCount        pgtype.Int4            `json:"member_count"`
	EventCount         pgtype.Int4            `json:"event_count"`
	IsActive           pgtype.Bool            `json:"is_active"`
	CreatedBy          pgtype.UUID            `json:"created_by"`
	CreatedAt          pgtype.Timestamptz     `json:"created_at"`
	Role               NullCommunityRole      `json:"role"`
	MemberStatus       NullMemberStatus       `json:"member_status"`
}

func (q *Queries) ListMyCommunities(ctx context.Context, userID pgtype.UUID) ([]ListMyCommunitiesRow, error) {
	rows, err := q.db.Query(ctx, listMyCommunities, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMyCommunitiesRow{}
	for rows.Next() {
		var i ListMyCommunitiesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Slug,
			&i.Description,
			&i.CommunityType,
			&i.AccessLevel,
			&i.VerificationStatus,
			&i.LogoUrl,
			&i.District,
			&i.MemberCount,
			&i.EventCount,
			&i.IsActive,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Role,
			&i.MemberStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCommunity = `-- name: UpdateCommunity :one
UPDATE communities SET
    name              = COALESCE($1, name),
    description       = COALESCE($2, description),
    rules             = COALESCE($3, rules),
    access_level      = COALESCE($4, access_level),
    logo_url          = COALESCE($5, logo_url),
    banner_url        = COALESCE($6, banner_url),
    contact_phone     = COALESCE($7, contact_phone),
    contact_email     = COALESCE($8, contact_email),
    social_links      = COALESCE($9, social_links),
    address           = COALESCE($10, address),
    district          = COALESCE($11, district),
    updated_at        = NOW()
WHERE id = $12 AND is_active = TRUE
RETURNING id, name, slug, description, rules, community_type, access_level,
    verification_status, verified_at, verification_documents,
    logo_url, banner_url, contact_phone, contact_email, social_links,
    address, district,
    rating_initial, rating_k_factor, rating_min_games,
    member_count, event_count, is_active,
    created_by, created_at, updated_at
`

type UpdateCommunityParams struct {
	Name         pgtype.Text         `json:"name"`
	Description  pgtype.Text         `json:"description"`
	Rules        pgtype.Text         `json:"rules"`
	AccessLevel  NullCommunityAccess `json:"access_level"`
	LogoUrl      pgtype.Text         `json:"logo_url"`
	BannerUrl    pgtype.Text         `json:"banner_url"`
	ContactPhone pgtype.Text         `json:"contact_phone"`
	ContactEmail pgtype.Text         `json:"contact_email"`
	SocialLinks  []byte              `json:"social_links"`
	Address      pgtype.Text         `json:"address"`
	District     pgtype.Text         `json:"district"`
	ID           pgtype.UUID         `json:"id"`
}

func (q *Queries) UpdateCommunity(ctx context.Context, arg UpdateCommunityParams) (Community, error) {
	row := q.db.QueryRow(ctx, updateCommunity,
		arg.Name,
		arg.Description,
		arg.Rules,
		arg.AccessLevel,
		arg.LogoUrl,
		arg.BannerUrl,
		arg.ContactPhone,
		arg.ContactEmail,
		arg.SocialLinks,
		arg.Address,
		arg.District,
		arg.ID,
	)
	var i Community
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Slug,
		&i.Description,
		&i.Rules,
		&i.CommunityType,
		&i.AccessLevel,
		&i.VerificationStatus,
		&i.VerifiedAt,
		&i.VerificationDocuments,
		&i.LogoUrl,
		&i.BannerUrl,
		&i.ContactPhone,
		&i.ContactEmail,
		&i.SocialLinks,
		&i.Address,
		&i.District,
		&i.RatingInitial,
		&i.RatingKFactor,
		&i.RatingMinGames,
		&i.MemberCount,
		&i.EventCount,
		&i.IsActive,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCommunityMemberRole = `-- name: UpdateCommunityMemberRole :one
UPDATE community_members SET
    role = $3,
    updated_at = NOW()
WHERE community_id = $1 AND user_id = $2
RETURNING id, community_id, user_id, role, status, application_message,
    reviewed_by, reviewed_at,
    community_rating, community_games_count, community_wins, community_losses,
    joined_at, updated_at
`

type UpdateCommunityMemberRoleParams struct {
	CommunityID pgtype.UUID       `json:"community_id"`
	UserID      pgtype.UUID       `json:"user_id"`
	Role        NullCommunityRole `json:"role"`
}

func (q *Queries) UpdateCommunityMemberRole(ctx context.Context, arg UpdateCommunityMemberRoleParams) (CommunityMember, error) {
	row := q.db.QueryRow(ctx, updateCommunityMemberRole, arg.CommunityID, arg.UserID, arg.Role)
	var i CommunityMember
	err := row.Scan(
		&i.ID,
		&i.CommunityID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.ApplicationMessage,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CommunityRating,
		&i.CommunityGamesCount,
		&i.CommunityWins,
		&i.CommunityLosses,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCommunityMemberStatus = `-- name: UpdateCommunityMemberStatus :one
UPDATE community_members SET
    status = $3,
    reviewed_by = $4,
    reviewed_at = NOW(),
    updated_at = NOW()
WHERE community_id = $1 AND user_id = $2
RETURNING id, community_id, user_id, role, status, application_message,
    reviewed_by, reviewed_at,
    community_rating, community_games_count, community_wins, community_losses,
    joined_at, updated_at
`

type UpdateCommunityMemberStatusParams struct {
	CommunityID pgtype.UUID      `json:"community_id"`
	UserID      pgtype.UUID      `json:"user_id"`
	Status      NullMemberStatus `json:"status"`
	ReviewedBy  pgtype.UUID      `json:"reviewed_by"`
}

func (q *Queries) UpdateCommunityMemberStatus(ctx context.Context, arg UpdateCommunityMemberStatusParams) (CommunityMember, error) {
	row := q.db.QueryRow(ctx, updateCommunityMemberStatus,
		arg.CommunityID,
		arg.UserID,
		arg.Status,
		arg.ReviewedBy,
	)
	var i CommunityMember
	err := row.Scan(
		&i.ID,
		&i.CommunityID,
		&i.UserID,
		&i.Role,
		&i.Status,
		&i.ApplicationMessage,
		&i.ReviewedBy,
		&i.ReviewedAt,
		&i.CommunityRating,
		&i.CommunityGamesCount,
		&i.CommunityWins,
		&i.CommunityLosses,
		&i.JoinedAt,
		&i.UpdatedAt,
	)
	return i, err
}
