// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: matches.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const adminConfirmMatch = `-- name: AdminConfirmMatch :one
UPDATE matches SET
    result_status = 'admin_confirmed',
    score = $1,
    winner_id = $2,
    confirmed_by = $3,
    confirmed_at = NOW(),
    player1_rating_before = $4,
    player1_rating_after = $5,
    player2_rating_before = $6,
    player2_rating_after = $7,
    updated_at = NOW()
WHERE id = $8
RETURNING id, event_id, community_id,
    player1_id, player2_id, player1_partner_id, player2_partner_id,
    composition, score, winner_id,
    result_status, submitted_by, confirmed_by, submitted_at, confirmed_at,
    dispute_reason,
    player1_rating_before, player1_rating_after,
    player2_rating_before, player2_rating_after,
    round_name, round_number, court_number,
    scheduled_time, played_at, created_at, updated_at
`

type AdminConfirmMatchParams struct {
	Score               []byte         `json:"score"`
	WinnerID            pgtype.UUID    `json:"winner_id"`
	ConfirmedBy         pgtype.UUID    `json:"confirmed_by"`
	Player1RatingBefore pgtype.Numeric `json:"player1_rating_before"`
	Player1RatingAfter  pgtype.Numeric `json:"player1_rating_after"`
	Player2RatingBefore pgtype.Numeric `json:"player2_rating_before"`
	Player2RatingAfter  pgtype.Numeric `json:"player2_rating_after"`
	ID                  pgtype.UUID    `json:"id"`
}

func (q *Queries) AdminConfirmMatch(ctx context.Context, arg AdminConfirmMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, adminConfirmMatch,
		arg.Score,
		arg.WinnerID,
		arg.ConfirmedBy,
		arg.Player1RatingBefore,
		arg.Player1RatingAfter,
		arg.Player2RatingBefore,
		arg.Player2RatingAfter,
		arg.ID,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CommunityID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Player1PartnerID,
		&i.Player2PartnerID,
		&i.Composition,
		&i.Score,
		&i.WinnerID,
		&i.ResultStatus,
		&i.SubmittedBy,
		&i.ConfirmedBy,
		&i.SubmittedAt,
		&i.ConfirmedAt,
		&i.DisputeReason,
		&i.Player1RatingBefore,
		&i.Player1RatingAfter,
		&i.Player2RatingBefore,
		&i.Player2RatingAfter,
		&i.RoundName,
		&i.RoundNumber,
		&i.CourtNumber,
		&i.ScheduledTime,
		&i.PlayedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const confirmMatch = `-- name: ConfirmMatch :one
UPDATE matches SET
    result_status = 'confirmed',
    confirmed_by = $1,
    confirmed_at = NOW(),
    player1_rating_before = $2,
    player1_rating_after = $3,
    player2_rating_before = $4,
    player2_rating_after = $5,
    updated_at = NOW()
WHERE id = $6
RETURNING id, event_id, community_id,
    player1_id, player2_id, player1_partner_id, player2_partner_id,
    composition, score, winner_id,
    result_status, submitted_by, confirmed_by, submitted_at, confirmed_at,
    dispute_reason,
    player1_rating_before, player1_rating_after,
    player2_rating_before, player2_rating_after,
    round_name, round_number, court_number,
    scheduled_time, played_at, created_at, updated_at
`

type ConfirmMatchParams struct {
	ConfirmedBy         pgtype.UUID    `json:"confirmed_by"`
	Player1RatingBefore pgtype.Numeric `json:"player1_rating_before"`
	Player1RatingAfter  pgtype.Numeric `json:"player1_rating_after"`
	Player2RatingBefore pgtype.Numeric `json:"player2_rating_before"`
	Player2RatingAfter  pgtype.Numeric `json:"player2_rating_after"`
	ID                  pgtype.UUID    `json:"id"`
}

func (q *Queries) ConfirmMatch(ctx context.Context, arg ConfirmMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, confirmMatch,
		arg.ConfirmedBy,
		arg.Player1RatingBefore,
		arg.Player1RatingAfter,
		arg.Player2RatingBefore,
		arg.Player2RatingAfter,
		arg.ID,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CommunityID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Player1PartnerID,
		&i.Player2PartnerID,
		&i.Composition,
		&i.Score,
		&i.WinnerID,
		&i.ResultStatus,
		&i.SubmittedBy,
		&i.ConfirmedBy,
		&i.SubmittedAt,
		&i.ConfirmedAt,
		&i.DisputeReason,
		&i.Player1RatingBefore,
		&i.Player1RatingAfter,
		&i.Player2RatingBefore,
		&i.Player2RatingAfter,
		&i.RoundName,
		&i.RoundNumber,
		&i.CourtNumber,
		&i.ScheduledTime,
		&i.PlayedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countGlobalLeaderboard = `-- name: CountGlobalLeaderboard :one
SELECT COUNT(*)
FROM users u
LEFT JOIN player_stats_global ps ON u.id = ps.user_id
WHERE u.status = 'active'
  AND u.global_rating IS NOT NULL
  AND ($1::int IS NULL OR COALESCE(ps.total_games, 0) >= $1::int)
`

func (q *Queries) CountGlobalLeaderboard(ctx context.Context, minGames pgtype.Int4) (int64, error) {
	row := q.db.QueryRow(ctx, countGlobalLeaderboard, minGames)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countMyMatches = `-- name: CountMyMatches :one
SELECT COUNT(*)
FROM matches
WHERE (player1_id = $1 OR player2_id = $1
       OR player1_partner_id = $1 OR player2_partner_id = $1)
  AND ($2::uuid IS NULL OR community_id = $2)
  AND ($3::uuid IS NULL OR
       (player1_id = $3 OR player2_id = $3))
  AND ($4::text IS NULL
       OR ($4::text = 'win' AND winner_id = $1)
       OR ($4::text = 'loss' AND winner_id IS NOT NULL AND winner_id != $1))
`

type CountMyMatchesParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	CommunityID  pgtype.UUID `json:"community_id"`
	OpponentID   pgtype.UUID `json:"opponent_id"`
	ResultFilter pgtype.Text `json:"result_filter"`
}

func (q *Queries) CountMyMatches(ctx context.Context, arg CountMyMatchesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMyMatches,
		arg.UserID,
		arg.CommunityID,
		arg.OpponentID,
		arg.ResultFilter,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMatch = `-- name: CreateMatch :one
INSERT INTO matches (
    event_id, community_id,
    player1_id, player2_id,
    player1_partner_id, player2_partner_id,
    composition,
    round_name, round_number, court_number,
    scheduled_time
) VALUES (
    $1, $2,
    $3, $4,
    $5, $6,
    $7,
    $8, $9, $10,
    $11
)
RETURNING id, event_id, community_id,
    player1_id, player2_id, player1_partner_id, player2_partner_id,
    composition, score, winner_id,
    result_status, submitted_by, confirmed_by, submitted_at, confirmed_at,
    dispute_reason,
    player1_rating_before, player1_rating_after,
    player2_rating_before, player2_rating_after,
    round_name, round_number, court_number,
    scheduled_time, played_at, created_at, updated_at
`

type CreateMatchParams struct {
	EventID          pgtype.UUID        `json:"event_id"`
	CommunityID      pgtype.UUID        `json:"community_id"`
	Player1ID        pgtype.UUID        `json:"player1_id"`
	Player2ID        pgtype.UUID        `json:"player2_id"`
	Player1PartnerID pgtype.UUID        `json:"player1_partner_id"`
	Player2PartnerID pgtype.UUID        `json:"player2_partner_id"`
	Composition      PlayerComposition  `json:"composition"`
	RoundName        pgtype.Text        `json:"round_name"`
	RoundNumber      pgtype.Int4        `json:"round_number"`
	CourtNumber      pgtype.Int4        `json:"court_number"`
	ScheduledTime    pgtype.Timestamptz `json:"scheduled_time"`
}

func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, createMatch,
		arg.EventID,
		arg.CommunityID,
		arg.Player1ID,
		arg.Player2ID,
		arg.Player1PartnerID,
		arg.Player2PartnerID,
		arg.Composition,
		arg.RoundName,
		arg.RoundNumber,
		arg.CourtNumber,
		arg.ScheduledTime,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CommunityID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Player1PartnerID,
		&i.Player2PartnerID,
		&i.Composition,
		&i.Score,
		&i.WinnerID,
		&i.ResultStatus,
		&i.SubmittedBy,
		&i.ConfirmedBy,
		&i.SubmittedAt,
		&i.ConfirmedAt,
		&i.DisputeReason,
		&i.Player1RatingBefore,
		&i.Player1RatingAfter,
		&i.Player2RatingBefore,
		&i.Player2RatingAfter,
		&i.RoundName,
		&i.RoundNumber,
		&i.CourtNumber,
		&i.ScheduledTime,
		&i.PlayedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const disputeMatch = `-- name: DisputeMatch :one
UPDATE matches SET
    result_status = 'disputed',
    dispute_reason = $1,
    updated_at = NOW()
WHERE id = $2
RETURNING id, event_id, community_id,
    player1_id, player2_id, player1_partner_id, player2_partner_id,
    composition, score, winner_id,
    result_status, submitted_by, confirmed_by, submitted_at, confirmed_at,
    dispute_reason,
    player1_rating_before, player1_rating_after,
    player2_rating_before, player2_rating_after,
    round_name, round_number, court_number,
    scheduled_time, played_at, created_at, updated_at
`

type DisputeMatchParams struct {
	DisputeReason pgtype.Text `json:"dispute_reason"`
	ID            pgtype.UUID `json:"id"`
}

func (q *Queries) DisputeMatch(ctx context.Context, arg DisputeMatchParams) (Match, error) {
	row := q.db.QueryRow(ctx, disputeMatch, arg.DisputeReason, arg.ID)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CommunityID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Player1PartnerID,
		&i.Player2PartnerID,
		&i.Composition,
		&i.Score,
		&i.WinnerID,
		&i.ResultStatus,
		&i.SubmittedBy,
		&i.ConfirmedBy,
		&i.SubmittedAt,
		&i.ConfirmedAt,
		&i.DisputeReason,
		&i.Player1RatingBefore,
		&i.Player1RatingAfter,
		&i.Player2RatingBefore,
		&i.Player2RatingAfter,
		&i.RoundName,
		&i.RoundNumber,
		&i.CourtNumber,
		&i.ScheduledTime,
		&i.PlayedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGlobalLeaderboard = `-- name: GetGlobalLeaderboard :many
SELECT
    u.id as user_id,
    u.first_name, u.last_name, u.avatar_url, u.ntrp_level,
    u.global_rating,
    COALESCE(ps.total_games, 0) as total_games,
    COALESCE(ps.total_wins, 0) as total_wins,
    COALESCE(ps.total_losses, 0) as total_losses,
    COALESCE(ps.win_rate, 0) as win_rate
FROM users u
LEFT JOIN player_stats_global ps ON u.id = ps.user_id
WHERE u.status = 'active'
  AND u.global_rating IS NOT NULL
  AND ($1::int IS NULL OR COALESCE(ps.total_games, 0) >= $1::int)
ORDER BY u.global_rating DESC
LIMIT $3 OFFSET $2
`

type GetGlobalLeaderboardParams struct {
	MinGames     pgtype.Int4 `json:"min_games"`
	ResultOffset int32       `json:"result_offset"`
	ResultLimit  int32       `json:"result_limit"`
}

type GetGlobalLeaderboardRow struct {
	UserID       pgtype.UUID    `json:"user_id"`
	FirstName    pgtype.Text    `json:"first_name"`
	LastName     pgtype.Text    `json:"last_name"`
	AvatarUrl    pgtype.Text    `json:"avatar_url"`
	NtrpLevel    pgtype.Numeric `json:"ntrp_level"`
	GlobalRating pgtype.Numeric `json:"global_rating"`
	TotalGames   int32          `json:"total_games"`
	TotalWins    int32          `json:"total_wins"`
	TotalLosses  int32          `json:"total_losses"`
	WinRate      pgtype.Numeric `json:"win_rate"`
}

func (q *Queries) GetGlobalLeaderboard(ctx context.Context, arg GetGlobalLeaderboardParams) ([]GetGlobalLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getGlobalLeaderboard, arg.MinGames, arg.ResultOffset, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetGlobalLeaderboardRow{}
	for rows.Next() {
		var i GetGlobalLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.FirstName,
			&i.LastName,
			&i.AvatarUrl,
			&i.NtrpLevel,
			&i.GlobalRating,
			&i.TotalGames,
			&i.TotalWins,
			&i.TotalLosses,
			&i.WinRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchByID = `-- name: GetMatchByID :one
SELECT id, event_id, community_id,
    player1_id, player2_id, player1_partner_id, player2_partner_id,
    composition, score, winner_id,
    result_status, submitted_by, confirmed_by, submitted_at, confirmed_at,
    dispute_reason,
    player1_rating_before, player1_rating_after,
    player2_rating_before, player2_rating_after,
    round_name, round_number, court_number,
    scheduled_time, played_at, created_at, updated_at
FROM matches
WHERE id = $1
`

func (q *Queries) GetMatchByID(ctx context.Context, id pgtype.UUID) (Match, error) {
	row := q.db.QueryRow(ctx, getMatchByID, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CommunityID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Player1PartnerID,
		&i.Player2PartnerID,
		&i.Composition,
		&i.Score,
		&i.WinnerID,
		&i.ResultStatus,
		&i.SubmittedBy,
		&i.ConfirmedBy,
		&i.SubmittedAt,
		&i.ConfirmedAt,
		&i.DisputeReason,
		&i.Player1RatingBefore,
		&i.Player1RatingAfter,
		&i.Player2RatingBefore,
		&i.Player2RatingAfter,
		&i.RoundName,
		&i.RoundNumber,
		&i.CourtNumber,
		&i.ScheduledTime,
		&i.PlayedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerTotalGames = `-- name: GetPlayerTotalGames :one
SELECT COALESCE(total_games, 0)::int as total_games
FROM player_stats_global
WHERE user_id = $1
`

func (q *Queries) GetPlayerTotalGames(ctx context.Context, userID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getPlayerTotalGames, userID)
	var total_games int32
	err := row.Scan(&total_games)
	return total_games, err
}

const getRatingHistory = `-- name: GetRatingHistory :many
SELECT id, user_id, community_id, rating_before, rating_after, change, match_id, reason, created_at
FROM rating_history
WHERE user_id = $1
  AND ($2::uuid IS NULL OR community_id = $2)
  AND ($3::timestamptz IS NULL OR created_at >= $3)
ORDER BY created_at DESC
LIMIT $5 OFFSET $4
`

type GetRatingHistoryParams struct {
	UserID       pgtype.UUID        `json:"user_id"`
	CommunityID  pgtype.UUID        `json:"community_id"`
	Since        pgtype.Timestamptz `json:"since"`
	ResultOffset int32              `json:"result_offset"`
	ResultLimit  int32              `json:"result_limit"`
}

func (q *Queries) GetRatingHistory(ctx context.Context, arg GetRatingHistoryParams) ([]RatingHistory, error) {
	rows, err := q.db.Query(ctx, getRatingHistory,
		arg.UserID,
		arg.CommunityID,
		arg.Since,
		arg.ResultOffset,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RatingHistory{}
	for rows.Next() {
		var i RatingHistory
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CommunityID,
			&i.RatingBefore,
			&i.RatingAfter,
			&i.Change,
			&i.MatchID,
			&i.Reason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserCommunityRatings = `-- name: GetUserCommunityRatings :many
SELECT
    cm.community_id,
    c.name as community_name,
    c.logo_url as community_logo,
    cm.community_rating,
    cm.community_games_count,
    cm.community_wins,
    cm.community_losses,
    (SELECT COUNT(*) FROM community_members cm2
     WHERE cm2.community_id = cm.community_id AND cm2.status = 'active'
       AND cm2.community_rating > cm.community_rating) + 1 as rank
FROM community_members cm
JOIN communities c ON cm.community_id = c.id
WHERE cm.user_id = $1 AND cm.status = 'active' AND c.is_active = TRUE
ORDER BY cm.community_rating DESC
`

type GetUserCommunityRatingsRow struct {
	CommunityID         pgtype.UUID    `json:"community_id"`
	CommunityName       string         `json:"community_name"`
	CommunityLogo       pgtype.Text    `json:"community_logo"`
	CommunityRating     pgtype.Numeric `json:"community_rating"`
	CommunityGamesCount pgtype.Int4    `json:"community_games_count"`
	CommunityWins       pgtype.Int4    `json:"community_wins"`
	CommunityLosses     pgtype.Int4    `json:"community_losses"`
	Rank                int32          `json:"rank"`
}

func (q *Queries) GetUserCommunityRatings(ctx context.Context, userID pgtype.UUID) ([]GetUserCommunityRatingsRow, error) {
	rows, err := q.db.Query(ctx, getUserCommunityRatings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserCommunityRatingsRow{}
	for rows.Next() {
		var i GetUserCommunityRatingsRow
		if err := rows.Scan(
			&i.CommunityID,
			&i.CommunityName,
			&i.CommunityLogo,
			&i.CommunityRating,
			&i.CommunityGamesCount,
			&i.CommunityWins,
			&i.CommunityLosses,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserForRating = `-- name: GetUserForRating :one
SELECT id, global_rating, ntrp_level
FROM users
WHERE id = $1
`

type GetUserForRatingRow struct {
	ID           pgtype.UUID    `json:"id"`
	GlobalRating pgtype.Numeric `json:"global_rating"`
	NtrpLevel    pgtype.Numeric `json:"ntrp_level"`
}

func (q *Queries) GetUserForRating(ctx context.Context, id pgtype.UUID) (GetUserForRatingRow, error) {
	row := q.db.QueryRow(ctx, getUserForRating, id)
	var i GetUserForRatingRow
	err := row.Scan(&i.ID, &i.GlobalRating, &i.NtrpLevel)
	return i, err
}

const getUserRatingPosition = `-- name: GetUserRatingPosition :one
SELECT
    u.global_rating,
    (SELECT COUNT(*) FROM users u2 WHERE u2.status = 'active' AND u2.global_rating > u.global_rating) + 1 as rank,
    (SELECT COUNT(*) FROM users u3 WHERE u3.status = 'active' AND u3.global_rating IS NOT NULL) as total_players
FROM users u
WHERE u.id = $1
`

type GetUserRatingPositionRow struct {
	GlobalRating pgtype.Numeric `json:"global_rating"`
	Rank         int32          `json:"rank"`
	TotalPlayers int64          `json:"total_players"`
}

func (q *Queries) GetUserRatingPosition(ctx context.Context, userID pgtype.UUID) (GetUserRatingPositionRow, error) {
	row := q.db.QueryRow(ctx, getUserRatingPosition, userID)
	var i GetUserRatingPositionRow
	err := row.Scan(&i.GlobalRating, &i.Rank, &i.TotalPlayers)
	return i, err
}

const insertRatingHistory = `-- name: InsertRatingHistory :one
INSERT INTO rating_history (
    user_id, community_id, rating_before, rating_after, change, match_id, reason
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, user_id, community_id, rating_before, rating_after, change, match_id, reason, created_at
`

type InsertRatingHistoryParams struct {
	UserID       pgtype.UUID    `json:"user_id"`
	CommunityID  pgtype.UUID    `json:"community_id"`
	RatingBefore pgtype.Numeric `json:"rating_before"`
	RatingAfter  pgtype.Numeric `json:"rating_after"`
	Change       pgtype.Numeric `json:"change"`
	MatchID      pgtype.UUID    `json:"match_id"`
	Reason       pgtype.Text    `json:"reason"`
}

func (q *Queries) InsertRatingHistory(ctx context.Context, arg InsertRatingHistoryParams) (RatingHistory, error) {
	row := q.db.QueryRow(ctx, insertRatingHistory,
		arg.UserID,
		arg.CommunityID,
		arg.RatingBefore,
		arg.RatingAfter,
		arg.Change,
		arg.MatchID,
		arg.Reason,
	)
	var i RatingHistory
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CommunityID,
		&i.RatingBefore,
		&i.RatingAfter,
		&i.Change,
		&i.MatchID,
		&i.Reason,
		&i.CreatedAt,
	)
	return i, err
}

const listMyMatches = `-- name: ListMyMatches :many
SELECT id, event_id, community_id,
    player1_id, player2_id, player1_partner_id, player2_partner_id,
    composition, score, winner_id,
    result_status, submitted_by, confirmed_by, submitted_at, confirmed_at,
    dispute_reason,
    player1_rating_before, player1_rating_after,
    player2_rating_before, player2_rating_after,
    round_name, round_number, court_number,
    scheduled_time, played_at, created_at, updated_at
FROM matches
WHERE (player1_id = $1 OR player2_id = $1
       OR player1_partner_id = $1 OR player2_partner_id = $1)
  AND ($2::uuid IS NULL OR community_id = $2)
  AND ($3::uuid IS NULL OR
       (player1_id = $3 OR player2_id = $3))
  AND ($4::text IS NULL
       OR ($4::text = 'win' AND winner_id = $1)
       OR ($4::text = 'loss' AND winner_id IS NOT NULL AND winner_id != $1))
ORDER BY COALESCE(played_at, created_at) DESC
LIMIT $6 OFFSET $5
`

type ListMyMatchesParams struct {
	UserID       pgtype.UUID `json:"user_id"`
	CommunityID  pgtype.UUID `json:"community_id"`
	OpponentID   pgtype.UUID `json:"opponent_id"`
	ResultFilter pgtype.Text `json:"result_filter"`
	ResultOffset int32       `json:"result_offset"`
	ResultLimit  int32       `json:"result_limit"`
}

func (q *Queries) ListMyMatches(ctx context.Context, arg ListMyMatchesParams) ([]Match, error) {
	rows, err := q.db.Query(ctx, listMyMatches,
		arg.UserID,
		arg.CommunityID,
		arg.OpponentID,
		arg.ResultFilter,
		arg.ResultOffset,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Match{}
	for rows.Next() {
		var i Match
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.CommunityID,
			&i.Player1ID,
			&i.Player2ID,
			&i.Player1PartnerID,
			&i.Player2PartnerID,
			&i.Composition,
			&i.Score,
			&i.WinnerID,
			&i.ResultStatus,
			&i.SubmittedBy,
			&i.ConfirmedBy,
			&i.SubmittedAt,
			&i.ConfirmedAt,
			&i.DisputeReason,
			&i.Player1RatingBefore,
			&i.Player1RatingAfter,
			&i.Player2RatingBefore,
			&i.Player2RatingAfter,
			&i.RoundName,
			&i.RoundNumber,
			&i.CourtNumber,
			&i.ScheduledTime,
			&i.PlayedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const submitMatchResult = `-- name: SubmitMatchResult :one
UPDATE matches SET
    score = $1,
    winner_id = $2,
    submitted_by = $3,
    submitted_at = NOW(),
    result_status = 'pending',
    played_at = COALESCE(played_at, NOW()),
    updated_at = NOW()
WHERE id = $4
RETURNING id, event_id, community_id,
    player1_id, player2_id, player1_partner_id, player2_partner_id,
    composition, score, winner_id,
    result_status, submitted_by, confirmed_by, submitted_at, confirmed_at,
    dispute_reason,
    player1_rating_before, player1_rating_after,
    player2_rating_before, player2_rating_after,
    round_name, round_number, court_number,
    scheduled_time, played_at, created_at, updated_at
`

type SubmitMatchResultParams struct {
	Score       []byte      `json:"score"`
	WinnerID    pgtype.UUID `json:"winner_id"`
	SubmittedBy pgtype.UUID `json:"submitted_by"`
	ID          pgtype.UUID `json:"id"`
}

func (q *Queries) SubmitMatchResult(ctx context.Context, arg SubmitMatchResultParams) (Match, error) {
	row := q.db.QueryRow(ctx, submitMatchResult,
		arg.Score,
		arg.WinnerID,
		arg.SubmittedBy,
		arg.ID,
	)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.CommunityID,
		&i.Player1ID,
		&i.Player2ID,
		&i.Player1PartnerID,
		&i.Player2PartnerID,
		&i.Composition,
		&i.Score,
		&i.WinnerID,
		&i.ResultStatus,
		&i.SubmittedBy,
		&i.ConfirmedBy,
		&i.SubmittedAt,
		&i.ConfirmedAt,
		&i.DisputeReason,
		&i.Player1RatingBefore,
		&i.Player1RatingAfter,
		&i.Player2RatingBefore,
		&i.Player2RatingAfter,
		&i.RoundName,
		&i.RoundNumber,
		&i.CourtNumber,
		&i.ScheduledTime,
		&i.PlayedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCommunityMemberStats = `-- name: UpdateCommunityMemberStats :exec
UPDATE community_members SET
    community_rating = $1,
    community_games_count = community_games_count + 1,
    community_wins = community_wins + CASE WHEN $2::boolean THEN 1 ELSE 0 END,
    community_losses = community_losses + CASE WHEN $2::boolean THEN 0 ELSE 1 END,
    updated_at = NOW()
WHERE community_id = $3 AND user_id = $4
`

type UpdateCommunityMemberStatsParams struct {
	NewRating   pgtype.Numeric `json:"new_rating"`
	IsWinner    bool           `json:"is_winner"`
	CommunityID pgtype.UUID    `json:"community_id"`
	UserID      pgtype.UUID    `json:"user_id"`
}

func (q *Queries) UpdateCommunityMemberStats(ctx context.Context, arg UpdateCommunityMemberStatsParams) error {
	_, err := q.db.Exec(ctx, updateCommunityMemberStats,
		arg.NewRating,
		arg.IsWinner,
		arg.CommunityID,
		arg.UserID,
	)
	return err
}

const updateUserNTRPLevel = `-- name: UpdateUserNTRPLevel :exec
UPDATE users SET
    ntrp_level = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateUserNTRPLevelParams struct {
	NtrpLevel pgtype.Numeric `json:"ntrp_level"`
	UserID    pgtype.UUID    `json:"user_id"`
}

func (q *Queries) UpdateUserNTRPLevel(ctx context.Context, arg UpdateUserNTRPLevelParams) error {
	_, err := q.db.Exec(ctx, updateUserNTRPLevel, arg.NtrpLevel, arg.UserID)
	return err
}

const updateUserRating = `-- name: UpdateUserRating :exec
UPDATE users SET
    global_rating = $1,
    updated_at = NOW()
WHERE id = $2
`

type UpdateUserRatingParams struct {
	NewRating pgtype.Numeric `json:"new_rating"`
	UserID    pgtype.UUID    `json:"user_id"`
}

func (q *Queries) UpdateUserRating(ctx context.Context, arg UpdateUserRatingParams) error {
	_, err := q.db.Exec(ctx, updateUserRating, arg.NewRating, arg.UserID)
	return err
}

const upsertPlayerStatsGlobal = `-- name: UpsertPlayerStatsGlobal :exec
INSERT INTO player_stats_global (
    user_id, total_games, total_wins, total_losses, win_rate,
    singles_games, singles_wins, doubles_games, doubles_wins,
    current_streak, best_streak, last_game_at, updated_at
) VALUES (
    $1, 1,
    CASE WHEN $2::boolean THEN 1 ELSE 0 END,
    CASE WHEN $2::boolean THEN 0 ELSE 1 END,
    CASE WHEN $2::boolean THEN 100.00 ELSE 0.00 END,
    CASE WHEN $3::boolean THEN 1 ELSE 0 END,
    CASE WHEN $3::boolean AND $2::boolean THEN 1 ELSE 0 END,
    CASE WHEN $3::boolean THEN 0 ELSE 1 END,
    CASE WHEN NOT $3::boolean AND $2::boolean THEN 1 ELSE 0 END,
    CASE WHEN $2::boolean THEN 1 ELSE 0 END,
    CASE WHEN $2::boolean THEN 1 ELSE 0 END,
    NOW(), NOW()
)
ON CONFLICT (user_id) DO UPDATE SET
    total_games = player_stats_global.total_games + 1,
    total_wins = player_stats_global.total_wins + CASE WHEN $2::boolean THEN 1 ELSE 0 END,
    total_losses = player_stats_global.total_losses + CASE WHEN $2::boolean THEN 0 ELSE 1 END,
    win_rate = ROUND(
        (player_stats_global.total_wins + CASE WHEN $2::boolean THEN 1 ELSE 0 END)::decimal /
        (player_stats_global.total_games + 1) * 100, 2
    ),
    singles_games = player_stats_global.singles_games + CASE WHEN $3::boolean THEN 1 ELSE 0 END,
    singles_wins = player_stats_global.singles_wins + CASE WHEN $3::boolean AND $2::boolean THEN 1 ELSE 0 END,
    doubles_games = player_stats_global.doubles_games + CASE WHEN $3::boolean THEN 0 ELSE 1 END,
    doubles_wins = player_stats_global.doubles_wins + CASE WHEN NOT $3::boolean AND $2::boolean THEN 1 ELSE 0 END,
    current_streak = CASE
        WHEN $2::boolean THEN player_stats_global.current_streak + 1
        ELSE 0
    END,
    best_streak = GREATEST(
        player_stats_global.best_streak,
        CASE WHEN $2::boolean THEN player_stats_global.current_streak + 1 ELSE 0 END
    ),
    last_game_at = NOW(),
    updated_at = NOW()
`

type UpsertPlayerStatsGlobalParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	IsWinner  bool        `json:"is_winner"`
	IsSingles bool        `json:"is_singles"`
}

func (q *Queries) UpsertPlayerStatsGlobal(ctx context.Context, arg UpsertPlayerStatsGlobalParams) error {
	_, err := q.db.Exec(ctx, upsertPlayerStatsGlobal, arg.UserID, arg.IsWinner, arg.IsSingles)
	return err
}
