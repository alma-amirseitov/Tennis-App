// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chats.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCommunityChat = `-- name: CreateCommunityChat :one
INSERT INTO chats (chat_type, community_id, name)
VALUES ('community', $1, $2)
RETURNING id, chat_type, community_id, event_id, user1_id, user2_id,
    name, is_archived, last_message_at, last_message_preview,
    pinned_message_id, created_at, updated_at
`

type CreateCommunityChatParams struct {
	CommunityID pgtype.UUID `json:"community_id"`
	Name        pgtype.Text `json:"name"`
}

type CreateCommunityChatRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateCommunityChat(ctx context.Context, arg CreateCommunityChatParams) (CreateCommunityChatRow, error) {
	row := q.db.QueryRow(ctx, createCommunityChat, arg.CommunityID, arg.Name)
	var i CreateCommunityChatRow
	err := row.Scan(
		&i.ID,
		&i.ChatType,
		&i.CommunityID,
		&i.EventID,
		&i.User1ID,
		&i.User2ID,
		&i.Name,
		&i.IsArchived,
		&i.LastMessageAt,
		&i.LastMessagePreview,
		&i.PinnedMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createEventChat = `-- name: CreateEventChat :one
INSERT INTO chats (chat_type, event_id, name)
VALUES ('event', $1, $2)
RETURNING id, chat_type, community_id, event_id, user1_id, user2_id,
    name, is_archived, last_message_at, last_message_preview,
    pinned_message_id, created_at, updated_at
`

type CreateEventChatParams struct {
	EventID pgtype.UUID `json:"event_id"`
	Name    pgtype.Text `json:"name"`
}

type CreateEventChatRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateEventChat(ctx context.Context, arg CreateEventChatParams) (CreateEventChatRow, error) {
	row := q.db.QueryRow(ctx, createEventChat, arg.EventID, arg.Name)
	var i CreateEventChatRow
	err := row.Scan(
		&i.ID,
		&i.ChatType,
		&i.CommunityID,
		&i.EventID,
		&i.User1ID,
		&i.User2ID,
		&i.Name,
		&i.IsArchived,
		&i.LastMessageAt,
		&i.LastMessagePreview,
		&i.PinnedMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (chat_id, sender_id, content, reply_to_id)
VALUES ($1, $2, $3, $4)
RETURNING id, chat_id, sender_id, content, reply_to_id, is_deleted, deleted_at, created_at
`

type CreateMessageParams struct {
	ChatID    pgtype.UUID `json:"chat_id"`
	SenderID  pgtype.UUID `json:"sender_id"`
	Content   string      `json:"content"`
	ReplyToID pgtype.UUID `json:"reply_to_id"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ChatID,
		arg.SenderID,
		arg.Content,
		arg.ReplyToID,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.ReplyToID,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const createPersonalChat = `-- name: CreatePersonalChat :one
INSERT INTO chats (chat_type, user1_id, user2_id)
VALUES ('personal', $1, $2)
RETURNING id, chat_type, community_id, event_id, user1_id, user2_id,
    name, is_archived, last_message_at, last_message_preview,
    pinned_message_id, created_at, updated_at
`

type CreatePersonalChatParams struct {
	User1ID pgtype.UUID `json:"user1_id"`
	User2ID pgtype.UUID `json:"user2_id"`
}

type CreatePersonalChatRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreatePersonalChat(ctx context.Context, arg CreatePersonalChatParams) (CreatePersonalChatRow, error) {
	row := q.db.QueryRow(ctx, createPersonalChat, arg.User1ID, arg.User2ID)
	var i CreatePersonalChatRow
	err := row.Scan(
		&i.ID,
		&i.ChatType,
		&i.CommunityID,
		&i.EventID,
		&i.User1ID,
		&i.User2ID,
		&i.Name,
		&i.IsArchived,
		&i.LastMessageAt,
		&i.LastMessagePreview,
		&i.PinnedMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatByID = `-- name: GetChatByID :one
SELECT id, chat_type, community_id, event_id, user1_id, user2_id,
    name, is_archived, last_message_at, last_message_preview,
    pinned_message_id, created_at, updated_at
FROM chats
WHERE id = $1
`

type GetChatByIDRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetChatByID(ctx context.Context, id pgtype.UUID) (GetChatByIDRow, error) {
	row := q.db.QueryRow(ctx, getChatByID, id)
	var i GetChatByIDRow
	err := row.Scan(
		&i.ID,
		&i.ChatType,
		&i.CommunityID,
		&i.EventID,
		&i.User1ID,
		&i.User2ID,
		&i.Name,
		&i.IsArchived,
		&i.LastMessageAt,
		&i.LastMessagePreview,
		&i.PinnedMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getChatMembersForCommunity = `-- name: GetChatMembersForCommunity :many
SELECT cm.user_id
FROM community_members cm
JOIN chats c ON c.community_id = cm.community_id
WHERE c.id = $1 AND cm.status = 'active'
`

func (q *Queries) GetChatMembersForCommunity(ctx context.Context, chatID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getChatMembersForCommunity, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var user_id pgtype.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMembersForEvent = `-- name: GetChatMembersForEvent :many
SELECT ep.user_id
FROM event_participants ep
JOIN chats c ON c.event_id = ep.event_id
WHERE c.id = $1 AND ep.status != 'cancelled'
`

func (q *Queries) GetChatMembersForEvent(ctx context.Context, chatID pgtype.UUID) ([]pgtype.UUID, error) {
	rows, err := q.db.Query(ctx, getChatMembersForEvent, chatID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []pgtype.UUID{}
	for rows.Next() {
		var user_id pgtype.UUID
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChatMembersForPersonal = `-- name: GetChatMembersForPersonal :many
SELECT user1_id, user2_id
FROM chats
WHERE id = $1 AND chat_type = 'personal'
`

type GetChatMembersForPersonalRow struct {
	User1ID pgtype.UUID `json:"user1_id"`
	User2ID pgtype.UUID `json:"user2_id"`
}

func (q *Queries) GetChatMembersForPersonal(ctx context.Context, id pgtype.UUID) ([]GetChatMembersForPersonalRow, error) {
	rows, err := q.db.Query(ctx, getChatMembersForPersonal, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetChatMembersForPersonalRow{}
	for rows.Next() {
		var i GetChatMembersForPersonalRow
		if err := rows.Scan(&i.User1ID, &i.User2ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommunityBasicInfo = `-- name: GetCommunityBasicInfo :one
SELECT id, name, logo_url
FROM communities
WHERE id = $1 AND is_active = TRUE
`

type GetCommunityBasicInfoRow struct {
	ID      pgtype.UUID `json:"id"`
	Name    string      `json:"name"`
	LogoUrl pgtype.Text `json:"logo_url"`
}

func (q *Queries) GetCommunityBasicInfo(ctx context.Context, id pgtype.UUID) (GetCommunityBasicInfoRow, error) {
	row := q.db.QueryRow(ctx, getCommunityBasicInfo, id)
	var i GetCommunityBasicInfoRow
	err := row.Scan(&i.ID, &i.Name, &i.LogoUrl)
	return i, err
}

const getCommunityChatByCommunityID = `-- name: GetCommunityChatByCommunityID :one
SELECT id, chat_type, community_id, event_id, user1_id, user2_id,
    name, is_archived, last_message_at, last_message_preview,
    pinned_message_id, created_at, updated_at
FROM chats
WHERE chat_type = 'community' AND community_id = $1
`

type GetCommunityChatByCommunityIDRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetCommunityChatByCommunityID(ctx context.Context, communityID pgtype.UUID) (GetCommunityChatByCommunityIDRow, error) {
	row := q.db.QueryRow(ctx, getCommunityChatByCommunityID, communityID)
	var i GetCommunityChatByCommunityIDRow
	err := row.Scan(
		&i.ID,
		&i.ChatType,
		&i.CommunityID,
		&i.EventID,
		&i.User1ID,
		&i.User2ID,
		&i.Name,
		&i.IsArchived,
		&i.LastMessageAt,
		&i.LastMessagePreview,
		&i.PinnedMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getEventBasicInfo = `-- name: GetEventBasicInfo :one
SELECT id, title
FROM events
WHERE id = $1
`

type GetEventBasicInfoRow struct {
	ID    pgtype.UUID `json:"id"`
	Title string      `json:"title"`
}

func (q *Queries) GetEventBasicInfo(ctx context.Context, id pgtype.UUID) (GetEventBasicInfoRow, error) {
	row := q.db.QueryRow(ctx, getEventBasicInfo, id)
	var i GetEventBasicInfoRow
	err := row.Scan(&i.ID, &i.Title)
	return i, err
}

const getEventChatByEventID = `-- name: GetEventChatByEventID :one
SELECT id, chat_type, community_id, event_id, user1_id, user2_id,
    name, is_archived, last_message_at, last_message_preview,
    pinned_message_id, created_at, updated_at
FROM chats
WHERE chat_type = 'event' AND event_id = $1
`

type GetEventChatByEventIDRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetEventChatByEventID(ctx context.Context, eventID pgtype.UUID) (GetEventChatByEventIDRow, error) {
	row := q.db.QueryRow(ctx, getEventChatByEventID, eventID)
	var i GetEventChatByEventIDRow
	err := row.Scan(
		&i.ID,
		&i.ChatType,
		&i.CommunityID,
		&i.EventID,
		&i.User1ID,
		&i.User2ID,
		&i.Name,
		&i.IsArchived,
		&i.LastMessageAt,
		&i.LastMessagePreview,
		&i.PinnedMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, chat_id, sender_id, content, reply_to_id, is_deleted, deleted_at, created_at
FROM messages
WHERE id = $1 AND is_deleted = FALSE
`

func (q *Queries) GetMessageByID(ctx context.Context, id pgtype.UUID) (Message, error) {
	row := q.db.QueryRow(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.ChatID,
		&i.SenderID,
		&i.Content,
		&i.ReplyToID,
		&i.IsDeleted,
		&i.DeletedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getMessages = `-- name: GetMessages :many
SELECT
    m.id, m.chat_id, m.sender_id, m.content, m.reply_to_id,
    m.is_deleted, m.deleted_at, m.created_at,
    u.first_name as sender_first_name,
    u.last_name as sender_last_name,
    u.avatar_url as sender_avatar_url
FROM messages m
JOIN users u ON m.sender_id = u.id
WHERE m.chat_id = $1
  AND m.is_deleted = FALSE
  AND ($2::uuid IS NULL OR m.id < $2)
ORDER BY m.created_at DESC
LIMIT $3
`

type GetMessagesParams struct {
	ChatID      pgtype.UUID `json:"chat_id"`
	BeforeID    pgtype.UUID `json:"before_id"`
	ResultLimit int32       `json:"result_limit"`
}

type GetMessagesRow struct {
	ID              pgtype.UUID        `json:"id"`
	ChatID          pgtype.UUID        `json:"chat_id"`
	SenderID        pgtype.UUID        `json:"sender_id"`
	Content         string             `json:"content"`
	ReplyToID       pgtype.UUID        `json:"reply_to_id"`
	IsDeleted       pgtype.Bool        `json:"is_deleted"`
	DeletedAt       pgtype.Timestamptz `json:"deleted_at"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	SenderFirstName pgtype.Text        `json:"sender_first_name"`
	SenderLastName  pgtype.Text        `json:"sender_last_name"`
	SenderAvatarUrl pgtype.Text        `json:"sender_avatar_url"`
}

func (q *Queries) GetMessages(ctx context.Context, arg GetMessagesParams) ([]GetMessagesRow, error) {
	rows, err := q.db.Query(ctx, getMessages, arg.ChatID, arg.BeforeID, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMessagesRow{}
	for rows.Next() {
		var i GetMessagesRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatID,
			&i.SenderID,
			&i.Content,
			&i.ReplyToID,
			&i.IsDeleted,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.SenderFirstName,
			&i.SenderLastName,
			&i.SenderAvatarUrl,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPersonalChat = `-- name: GetPersonalChat :one
SELECT id, chat_type, community_id, event_id, user1_id, user2_id,
    name, is_archived, last_message_at, last_message_preview,
    pinned_message_id, created_at, updated_at
FROM chats
WHERE chat_type = 'personal'
  AND user1_id = $1 AND user2_id = $2
`

type GetPersonalChatParams struct {
	User1ID pgtype.UUID `json:"user1_id"`
	User2ID pgtype.UUID `json:"user2_id"`
}

type GetPersonalChatRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetPersonalChat(ctx context.Context, arg GetPersonalChatParams) (GetPersonalChatRow, error) {
	row := q.db.QueryRow(ctx, getPersonalChat, arg.User1ID, arg.User2ID)
	var i GetPersonalChatRow
	err := row.Scan(
		&i.ID,
		&i.ChatType,
		&i.CommunityID,
		&i.EventID,
		&i.User1ID,
		&i.User2ID,
		&i.Name,
		&i.IsArchived,
		&i.LastMessageAt,
		&i.LastMessagePreview,
		&i.PinnedMessageID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalUnreadCount = `-- name: GetTotalUnreadCount :one
SELECT COALESCE(SUM(unread), 0)::int as total_unread
FROM (
    SELECT
        (SELECT COUNT(*) FROM messages m
         WHERE m.chat_id = c.id
           AND m.is_deleted = FALSE
           AND m.sender_id != $1
           AND (crs.last_read_at IS NULL OR m.created_at > crs.last_read_at)
        ) as unread
    FROM chats c
    LEFT JOIN chat_read_status crs ON c.id = crs.chat_id AND crs.user_id = $1
    WHERE (
        (c.chat_type = 'personal' AND (c.user1_id = $1 OR c.user2_id = $1))
        OR (c.chat_type = 'community' AND EXISTS (
            SELECT 1 FROM community_members cm
            WHERE cm.community_id = c.community_id AND cm.user_id = $1 AND cm.status = 'active'
        ))
        OR (c.chat_type = 'event' AND EXISTS (
            SELECT 1 FROM event_participants ep
            WHERE ep.event_id = c.event_id AND ep.user_id = $1 AND ep.status != 'cancelled'
        ))
    )
    AND c.is_archived = FALSE
    AND COALESCE(crs.is_muted, FALSE) = FALSE
) sub
`

func (q *Queries) GetTotalUnreadCount(ctx context.Context, userID pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getTotalUnreadCount, userID)
	var total_unread int32
	err := row.Scan(&total_unread)
	return total_unread, err
}

const getUserBasicInfo = `-- name: GetUserBasicInfo :one
SELECT id, first_name, last_name, avatar_url
FROM users
WHERE id = $1 AND status = 'active'
`

type GetUserBasicInfoRow struct {
	ID        pgtype.UUID `json:"id"`
	FirstName pgtype.Text `json:"first_name"`
	LastName  pgtype.Text `json:"last_name"`
	AvatarUrl pgtype.Text `json:"avatar_url"`
}

func (q *Queries) GetUserBasicInfo(ctx context.Context, id pgtype.UUID) (GetUserBasicInfoRow, error) {
	row := q.db.QueryRow(ctx, getUserBasicInfo, id)
	var i GetUserBasicInfoRow
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.AvatarUrl,
	)
	return i, err
}

const isUserInChat = `-- name: IsUserInChat :one
SELECT EXISTS (
    SELECT 1 FROM chats c
    WHERE c.id = $1
    AND (
        (c.chat_type = 'personal' AND (c.user1_id = $2 OR c.user2_id = $2))
        OR (c.chat_type = 'community' AND EXISTS (
            SELECT 1 FROM community_members cm
            WHERE cm.community_id = c.community_id AND cm.user_id = $2 AND cm.status = 'active'
        ))
        OR (c.chat_type = 'event' AND EXISTS (
            SELECT 1 FROM event_participants ep
            WHERE ep.event_id = c.event_id AND ep.user_id = $2 AND ep.status != 'cancelled'
        ))
    )
) as is_member
`

type IsUserInChatParams struct {
	ChatID pgtype.UUID `json:"chat_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) IsUserInChat(ctx context.Context, arg IsUserInChatParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInChat, arg.ChatID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const listMyChats = `-- name: ListMyChats :many
SELECT
    c.id, c.chat_type, c.community_id, c.event_id, c.user1_id, c.user2_id,
    c.name, c.is_archived, c.last_message_at, c.last_message_preview,
    c.pinned_message_id, c.created_at, c.updated_at,
    COALESCE(crs.is_muted, FALSE) as is_muted,
    crs.last_read_at,
    -- Count unread messages
    (SELECT COUNT(*) FROM messages m
     WHERE m.chat_id = c.id
       AND m.is_deleted = FALSE
       AND m.sender_id != $1
       AND (crs.last_read_at IS NULL OR m.created_at > crs.last_read_at)
    )::int as unread_count,
    -- Other user info for personal chats
    CASE WHEN c.chat_type = 'personal' AND c.user1_id = $1 THEN c.user2_id
         WHEN c.chat_type = 'personal' AND c.user2_id = $1 THEN c.user1_id
         ELSE NULL END as other_user_id
FROM chats c
LEFT JOIN chat_read_status crs ON c.id = crs.chat_id AND crs.user_id = $1
WHERE (
    -- Personal chats: user is user1 or user2
    (c.chat_type = 'personal' AND (c.user1_id = $1 OR c.user2_id = $1))
    -- Community chats: user is member of community
    OR (c.chat_type = 'community' AND EXISTS (
        SELECT 1 FROM community_members cm
        WHERE cm.community_id = c.community_id AND cm.user_id = $1 AND cm.status = 'active'
    ))
    -- Event chats: user is participant
    OR (c.chat_type = 'event' AND EXISTS (
        SELECT 1 FROM event_participants ep
        WHERE ep.event_id = c.event_id AND ep.user_id = $1 AND ep.status != 'cancelled'
    ))
)
AND c.is_archived = FALSE
ORDER BY COALESCE(c.last_message_at, c.created_at) DESC
`

type ListMyChatsRow struct {
	ID                 pgtype.UUID        `json:"id"`
	ChatType           ChatType           `json:"chat_type"`
	CommunityID        pgtype.UUID        `json:"community_id"`
	EventID            pgtype.UUID        `json:"event_id"`
	User1ID            pgtype.UUID        `json:"user1_id"`
	User2ID            pgtype.UUID        `json:"user2_id"`
	Name               pgtype.Text        `json:"name"`
	IsArchived         pgtype.Bool        `json:"is_archived"`
	LastMessageAt      pgtype.Timestamptz `json:"last_message_at"`
	LastMessagePreview pgtype.Text        `json:"last_message_preview"`
	PinnedMessageID    pgtype.UUID        `json:"pinned_message_id"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	UpdatedAt          pgtype.Timestamptz `json:"updated_at"`
	IsMuted            bool               `json:"is_muted"`
	LastReadAt         pgtype.Timestamptz `json:"last_read_at"`
	UnreadCount        int32              `json:"unread_count"`
	OtherUserID        interface{}        `json:"other_user_id"`
}

func (q *Queries) ListMyChats(ctx context.Context, userID pgtype.UUID) ([]ListMyChatsRow, error) {
	rows, err := q.db.Query(ctx, listMyChats, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMyChatsRow{}
	for rows.Next() {
		var i ListMyChatsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChatType,
			&i.CommunityID,
			&i.EventID,
			&i.User1ID,
			&i.User2ID,
			&i.Name,
			&i.IsArchived,
			&i.LastMessageAt,
			&i.LastMessagePreview,
			&i.PinnedMessageID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsMuted,
			&i.LastReadAt,
			&i.UnreadCount,
			&i.OtherUserID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChatLastMessage = `-- name: UpdateChatLastMessage :exec
UPDATE chats SET
    last_message_at = $1,
    last_message_preview = $2,
    updated_at = NOW()
WHERE id = $3
`

type UpdateChatLastMessageParams struct {
	LastMessageAt pgtype.Timestamptz `json:"last_message_at"`
	Preview       pgtype.Text        `json:"preview"`
	ID            pgtype.UUID        `json:"id"`
}

func (q *Queries) UpdateChatLastMessage(ctx context.Context, arg UpdateChatLastMessageParams) error {
	_, err := q.db.Exec(ctx, updateChatLastMessage, arg.LastMessageAt, arg.Preview, arg.ID)
	return err
}

const updateChatMuted = `-- name: UpdateChatMuted :exec
INSERT INTO chat_read_status (chat_id, user_id, is_muted)
VALUES ($1, $2, $3)
ON CONFLICT (chat_id, user_id) DO UPDATE SET
    is_muted = $3
`

type UpdateChatMutedParams struct {
	ChatID  pgtype.UUID `json:"chat_id"`
	UserID  pgtype.UUID `json:"user_id"`
	IsMuted pgtype.Bool `json:"is_muted"`
}

func (q *Queries) UpdateChatMuted(ctx context.Context, arg UpdateChatMutedParams) error {
	_, err := q.db.Exec(ctx, updateChatMuted, arg.ChatID, arg.UserID, arg.IsMuted)
	return err
}

const upsertChatReadStatus = `-- name: UpsertChatReadStatus :exec
INSERT INTO chat_read_status (chat_id, user_id, last_read_at)
VALUES ($1, $2, $3)
ON CONFLICT (chat_id, user_id) DO UPDATE SET
    last_read_at = $3
`

type UpsertChatReadStatusParams struct {
	ChatID     pgtype.UUID        `json:"chat_id"`
	UserID     pgtype.UUID        `json:"user_id"`
	LastReadAt pgtype.Timestamptz `json:"last_read_at"`
}

func (q *Queries) UpsertChatReadStatus(ctx context.Context, arg UpsertChatReadStatusParams) error {
	_, err := q.db.Exec(ctx, upsertChatReadStatus, arg.ChatID, arg.UserID, arg.LastReadAt)
	return err
}
